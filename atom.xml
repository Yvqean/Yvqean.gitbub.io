<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Yvqean.github.io</id>
    <title>雨覃Yvqean-Blog</title>
    <updated>2022-07-01T02:22:50.268Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Yvqean.github.io"/>
    <link rel="self" href="https://Yvqean.github.io/atom.xml"/>
    <subtitle>一个兴趣使然的网站</subtitle>
    <logo>https://Yvqean.github.io/images/avatar.png</logo>
    <icon>https://Yvqean.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 雨覃Yvqean-Blog</rights>
    <entry>
        <title type="html"><![CDATA[roms_upwelling.in]]></title>
        <id>https://Yvqean.github.io/post/roms_upwellingin/</id>
        <link href="https://Yvqean.github.io/post/roms_upwellingin/">
        </link>
        <updated>2022-07-01T02:10:49.000Z</updated>
        <content type="html"><![CDATA[<p>ROMS/TOMS Standard Input parameters.</p>
<h1 id="svn-id-roms_upwellingin-1087-2021-09-10-011117z-arango-hernan-g-arango-copyright-c-2002-2021-the-romstoms-grouplicensed-under-a-mitx-style-licensesee-license_romstxt">svn $Id: roms_upwelling.in 1087 2021-09-10 01:11:17Z arango $<br>
========================================================= Hernan G. Arango ===<br>
Copyright (c) 2002-2021 The ROMS/TOMS Group<br>
Licensed under a MIT/X style license<br>
See License_ROMS.txt</h1>
<p>Input parameters can be entered in ANY order, provided that the parameter KEYWORD (usually, upper case) is typed correctly followed by &quot;=&quot;  or &quot;==&quot; symbols. Any comment lines are allowed and must begin with an exclamation mark () in column one.  Comments may appear to the right of a parameter<br>
specification to improve documentation.  Comments are ignored during<br>
reading.  Blank lines are also allowed and ignored. Continuation lines in<br>
a parameter specification are allowed if preceded by a backslash ().  In<br>
some instances, more than one value is required for a parameter.  If fewer<br>
values are provided, the last value is assigned for the entire parameter<br>
array.  The multiplication symbol (*),  without blank spaces in between,<br>
is allowed for a parameter specification. For example, in two grids nested<br>
application:</p>
<pre><code>AKT_BAK == 2*1.0d-6  2*5.0d-6               m2/s                        
</code></pre>
<p>indicates that the first two entries of array AKT_BAK,  in fortran column-<br>
major order, will have the same value of &quot;1.0d-6&quot; for grid 1,  whereas the<br>
next two entries will have the same value of &quot;5.0d-6&quot; for grid 2.</p>
<p>In multiple levels of nesting or multiple connected domains step-ups,<br>
&quot;Ngrids&quot; entries are expected for some of these parameters. In such case,<br>
the order of the entries for a parameter is critical. It must follow the<br>
same order (1:Ngrids) as in the state variable declaration. The USER may<br>
follow the above guidelines for specifying his/her values. These parameters<br>
are marked by &quot;==&quot; plural symbol after the KEYWORD.</p>
<p>Multiple NetCDF files are allowed for input field(s). It is useful when<br>
splitting input data (climatology,  boundary,  forcing) time records into<br>
several files (say monthly, annual, etc.). In this case, each multiple<br>
filename entry lines need to end with the vertical bar (|) symbol. For<br>
example:</p>
<pre><code>NFFILES == 6                           number of forcing files          
                                                                         
FRCNAME == my_lwrad_year1.nc |                                           
           my_lwrad_year2.nc \                                           
           my_swrad_year1.nc |                                           
           my_swrad_year2.nc \                                           
           my_winds_year1.nc |                                           
           my_winds_year2.nc \                                           
           my_Pair_year1.nc  |                                           
           my_Pair_year2.nc  \                                           
           my_Qair_year1.nc  |                                           
           my_Qair_year2.nc  \                                           
           my_Tair_year1.nc  |                                           
           my_Tair_year2.nc                                              
</code></pre>
<p>Notice that NFFILES is 6 and not 12. There are 6 uniquely different fields<br>
in the file list,  we  DO NOT  count file entries followed by the vertical<br>
bar symbol.  This is because  multiple file  entries are processed in ROMS<br>
with derived type structures.</p>
<p>==============================================================================</p>
<p>Application title.</p>
<pre><code>   TITLE = Wind-Driven Upwelling/Downwelling over a Periodic Channel
</code></pre>
<p>C-preprocessing Flag.</p>
<pre><code>MyAppCPP = UPWELLING
</code></pre>
<p>Input variable information file name.  This file needs to be processed<br>
first so all information arrays can be initialized properly.</p>
<pre><code> VARNAME = ROMS/External/varinfo.dat
</code></pre>
<p>Number of nested grids.</p>
<pre><code>  Ngrids =  1
</code></pre>
<p>Number of grid nesting layers.  This parameter is used to allow refinement<br>
and composite grid combinations.</p>
<p>NestLayers =  1</p>
<p>Number of grids in each nesting layer [1:NestLayers].</p>
<p>GridsInLayer =  1</p>
<p>Grid dimension parameters. See notes below in the Glossary for how to set<br>
these parameters correctly.</p>
<pre><code>      Lm == 41             Number of I-direction INTERIOR RHO-points
      Mm == 80             Number of J-direction INTERIOR RHO-points
       N == 16             Number of vertical levels

    Nbed =  0              Number of sediment bed layers

     NAT =  2              Number of active tracers (usually, 2)
     NPT =  0              Number of inactive passive tracers
     NCS =  0              Number of cohesive (mud) sediment tracers
     NNS =  0              Number of non-cohesive (sand) sediment tracers
</code></pre>
<p>Domain decomposition parameters for serial, distributed-memory or<br>
shared-memory configurations used to determine tile horizontal range<br>
indices (Istr,Iend) and (Jstr,Jend), [1:Ngrids].</p>
<pre><code>  NtileI == 1                                I-direction partition
  NtileJ == 1                                J-direction partition
</code></pre>
<p>Set horizontal and vertical advection schemes for active and inert<br>
tracers. A different advection scheme is allowed for each tracer.<br>
For example, a positive-definite (monotonic) algorithm can be activated<br>
for salinity and inert tracers, while a different one is set for<br>
temperature. [1:NAT+NPT,Ngrids] values are expected.</p>
<p>Keyword    Advection Algorithm</p>
<p>A4         4th-order Akima (horizontal/vertical)<br>
C2         2nd-order centered differences (horizontal/vertical)<br>
C4         4th-order centered differences (horizontal/vertical)<br>
HSIMT      3th-order HSIMT-TVD (horizontal/vertical)<br>
MPDATA     recursive flux corrected MPDATA (horizontal/vertical)<br>
SPLINES    parabolic splines (only vertical)<br>
SU3        split third-order upstream (horizontal/vertical)<br>
U3         3rd-order upstream-biased (only horizontal)</p>
<p>The user has the option of specifying the full Keyword or the first<br>
two letters, regardless if using uppercase or lowercase. If nested<br>
grids, specify values for each grid (see glossary below).</p>
<p>Hadvection == U3       \                      temperature<br>
U3                              salinity</p>
<p>Vadvection == C4       \                      temperature<br>
C4                              salinity</p>
<p>Adjoint-based algorithms can have different horizontal and schemes<br>
for active and inert tracers.</p>
<p>ad_Hadvection == U3       \                      temperature<br>
U3                              salinity</p>
<p>ad_Vadvection == C4       \                      temperature<br>
C4                              salinity</p>
<p>Set lateral boundary conditions keyword. Notice that a value is expected<br>
for each boundary segment per nested grid for each state variable.</p>
<p>Each tracer variable requires [1:4,1:NAT+NPT,Ngrids] values. Otherwise,<br>
[1:4,1:Ngrids] values are expected for other variables. The boundary<br>
order is: 1=west, 2=south, 3=east, and 4=north. That is, anticlockwise<br>
starting at the western boundary.</p>
<p>The keyword is case insensitive and usually has three characters. However,<br>
it is possible to have compound keywords, if applicable. For example, the<br>
keyword &quot;RadNud&quot; implies radiation boundary condition with nudging. This<br>
combination is usually used in active/passive radiation conditions.</p>
<p>Keyword    Lateral Boundary Condition Type</p>
<p>Cha        Chapman_implicit (free-surface)<br>
Che        Chapman_explicit (free-surface)<br>
Cla        Clamped<br>
Clo        Closed<br>
Fla        Flather (2D momentum)                  <em><strong><strong>N</strong></strong></em>     j=Mm<br>
Gra        Gradient                              |     4     |<br>
Nes        Nested (refinement)                   |           |<br>
Nud        Nudging                             1 W           E 3<br>
Per        Periodic                              |           |<br>
Rad        Radiation                             |<em><strong><strong>S</strong></strong></em>|<br>
Red        Reduced Physics (2D momentum)               2          j=1<br>
Shc        Shchepetkin (2D momentum)            i=1         i=Lm</p>
<pre><code>               W       S       E       N
               e       o       a       o
               s       u       s       r
               t       t       t       t
                       h               h

               1       2       3       4
</code></pre>
<p>LBC(isFsur) ==   Per     Clo     Per     Clo          free-surface<br>
LBC(isUbar) ==   Per     Clo     Per     Clo          2D U-momentum<br>
LBC(isVbar) ==   Per     Clo     Per     Clo          2D V-momentum<br>
LBC(isUvel) ==   Per     Clo     Per     Clo          3D U-momentum<br>
LBC(isVvel) ==   Per     Clo     Per     Clo          3D V-momentum<br>
LBC(isMtke) ==   Per     Clo     Per     Clo          mixing TKE</p>
<p>LBC(isTvar) ==   Per     Clo     Per     Clo \        temperature<br>
Per     Clo     Per     Clo          salinity</p>
<p>Adjoint-based algorithms can have different lateral boundary<br>
conditions keywords.</p>
<p>ad_LBC(isFsur) ==   Per     Clo     Per     Clo          free-surface<br>
ad_LBC(isUbar) ==   Per     Clo     Per     Clo          2D U-momentum<br>
ad_LBC(isVbar) ==   Per     Clo     Per     Clo          2D V-momentum<br>
ad_LBC(isUvel) ==   Per     Clo     Per     Clo          3D U-momentum<br>
ad_LBC(isVvel) ==   Per     Clo     Per     Clo          3D V-momentum<br>
ad_LBC(isMtke) ==   Per     Clo     Per     Clo          mixing TKE</p>
<p>ad_LBC(isTvar) ==   Per     Clo     Per     Clo \        temperature<br>
Per     Clo     Per     Clo          salinity</p>
<p>Set lateral open boundary edge volume conservation switch for<br>
nonlinear model and adjoint-based algorithms. Usually activated<br>
with radiation boundary conditions to enforce global mass<br>
conservation, except if tidal forcing is enabled. [1:Ngrids].</p>
<p>VolCons(west)  ==  F                             western  boundary<br>
VolCons(east)  ==  F                             eastern  boundary<br>
VolCons(south) ==  F                             southern boundary<br>
VolCons(north) ==  F                             northern boundary</p>
<p>ad_VolCons(west)  ==  F                             western  boundary<br>
ad_VolCons(east)  ==  F                             eastern  boundary<br>
ad_VolCons(south) ==  F                             southern boundary<br>
ad_VolCons(north) ==  F                             northern boundary</p>
<p>Time-Stepping parameters.</p>
<pre><code>  NTIMES == 1440
      DT == 300.0d0
 NDTFAST == 30
</code></pre>
<p>Number of timesteps for computing observation impacts during the<br>
analysis-forecast cycle.</p>
<p>NTIMES_ANA == 1440                                analysis interval<br>
NTIMES_FCT == 1440                                forecast interval</p>
<p>Model iteration loops parameters.</p>
<pre><code>   ERstr =  1
   ERend =  1
  Nouter =  1
  Ninner =  1
 Nsaddle =  1
</code></pre>
<p>Nintervals =  1</p>
<p>Number of eigenvalues (NEV) and eigenvectors (NCV) to compute for the<br>
Lanczos/Arnoldi problem in the Generalized Stability Theory (GST)<br>
analysis. NCV must be greater than NEV (see documentation below).</p>
<pre><code>     NEV =  2                                Number of eigenvalues
     NCV =  10                               Number of eigenvectors
</code></pre>
<p>Input/Output parameters.</p>
<pre><code>   NRREC == 0
</code></pre>
<p>LcycleRST == T<br>
NRST == 288<br>
NSTA == 1<br>
NFLT == 1<br>
NINFO == 1</p>
<p>Output history, quicksave, average, and diagnostic files parameters.</p>
<pre><code> LDEFOUT == T
    NHIS == 72
 NDEFHIS == 0
    NQCK == 0
 NDEFQCK == 0
  NTSAVG == 1
    NAVG == 72
 NDEFAVG == 0
  NTSDIA == 1
    NDIA == 72
 NDEFDIA == 0
</code></pre>
<p>Output tangent linear and adjoint models parameters.</p>
<p>LcycleTLM == F<br>
NTLM == 72<br>
NDEFTLM == 0<br>
LcycleADJ == F<br>
NADJ == 72<br>
NDEFADJ == 0<br>
NSFF == 72<br>
NOBC == 72</p>
<p>GST output and check pointing restart parameters.</p>
<p>LmultiGST =  F                                one eigenvector per file<br>
LrstGST =  F                                GST restart switch<br>
MaxIterGST =  500                              maximum number of iterations<br>
NGST =  10                               check pointing interval</p>
<p>Relative accuracy of the Ritz values computed in the GST analysis.</p>
<pre><code>Ritz_tol =  1.0d-15
</code></pre>
<p>Harmonic/biharmonic horizontal diffusion of tracer for nonlinear model<br>
and adjoint-based algorithms: [1:NAT+NPT,Ngrids].</p>
<pre><code>    TNU2 == 0.0d0  0.0d0                     m2/s
    TNU4 == 2*0.0d0                          m4/s

 ad_TNU2 == 0.0d0  0.0d0                     m2/s
 ad_TNU4 == 0.0d0  0.0d0                     m4/s
</code></pre>
<p>Harmonic/biharmonic, horizontal viscosity coefficient for nonlinear model<br>
and adjoint-based algorithms: [Ngrids].</p>
<pre><code>   VISC2 == 5.0d0                            m2/s
   VISC4 == 0.0d0                            m4/s

ad_VISC2 == 0.0d0                            m2/s
ad_VISC4 == 0.0d0                            m4/s
</code></pre>
<p>Logical switches (TRUE/FALSE) to increase/decrease horizontal viscosity<br>
and/or diffusivity in specific areas of the application domain (like<br>
sponge areas) for the desired application grid.</p>
<pre><code>LuvSponge == F                               horizontal momentum
</code></pre>
<p>LtracerSponge == F F                             temperature, salinity, inert</p>
<p>Vertical mixing coefficients for tracers in nonlinear model and<br>
basic state scale factor in adjoint-based algorithms: [1:NAT+NPT,Ngrids]</p>
<pre><code> AKT_BAK == 1.0d-6 1.0d-6                    m2/s
</code></pre>
<p>ad_AKT_fac == 1.0d0  1.0d0                     nondimensional</p>
<p>Vertical mixing coefficient for momentum for nonlinear model and<br>
basic state scale factor in adjoint-based algorithms: [Ngrids].</p>
<pre><code> AKV_BAK == 1.0d-5                           m2/s
</code></pre>
<p>ad_AKV_fac == 1.0d0                            nondimensional</p>
<p>Upper threshold values to limit vertical mixing coefficients computed<br>
from vertical mixing parameterizations. Although this is an engineering<br>
fix, the vertical mixing values inferred from ocean observations are<br>
rarely higher than this upper limit value.</p>
<p>AKT_LIMIT == 1.0d-3 1.0d-3                    m2/s</p>
<p>AKV_LIMIT == 1.0d-3                           m2/s</p>
<p>Turbulent closure parameters.</p>
<pre><code> AKK_BAK == 5.0d-6                           m2/s
 AKP_BAK == 5.0d-6                           m2/s
  TKENU2 == 0.0d0                            m2/s
  TKENU4 == 0.0d0                            m4/s
</code></pre>
<p>Generic length-scale turbulence closure parameters.</p>
<pre><code>   GLS_P == 3.0d0                            K-epsilon
   GLS_M == 1.5d0
   GLS_N == -1.0d0
GLS_Kmin == 7.6d-6
GLS_Pmin == 1.0d-12

GLS_CMU0 == 0.5477d0
  GLS_C1 == 1.44d0
  GLS_C2 == 1.92d0
 GLS_C3M == -0.4d0
 GLS_C3P == 1.0d0
GLS_SIGK == 1.0d0
GLS_SIGP == 1.30d0
</code></pre>
<p>Constants used in surface turbulent kinetic energy flux computation.</p>
<p>CHARNOK_ALPHA == 1400.0d0          Charnok surface roughness<br>
ZOS_HSIG_ALPHA == 0.5d0             roughness from wave amplitude<br>
SZ_ALPHA == 0.25d0            roughness from wave dissipation<br>
CRGBAN_CW == 100.0d0           Craig and Banner wave breaking</p>
<p>Constants used in momentum stress computation.</p>
<pre><code>    RDRG == 3.0d-04                     m/s
   RDRG2 == 3.0d-03                     nondimensional
     Zob == 0.02d0                      m
     Zos == 0.02d0                      m
</code></pre>
<p>Height (m) of atmospheric measurements for Bulk fluxes parameterization.</p>
<pre><code>  BLK_ZQ == 10.0d0                      air humidity
  BLK_ZT == 10.0d0                      air temperature
  BLK_ZW == 10.0d0                      winds
</code></pre>
<p>Minimum depth for wetting and drying.</p>
<pre><code>   DCRIT == 0.10d0                      m
</code></pre>
<p>Various parameters.</p>
<pre><code>   WTYPE == 1
 LEVSFRC == 15
 LEVBFRC == 1
</code></pre>
<p>Set vertical, terrain-following coordinates transformation equation and<br>
stretching function (see below for details), [1:Ngrids].</p>
<p>Vtransform == 2                           transformation equation<br>
Vstretching == 4                           stretching function</p>
<p>Vertical S-coordinates parameters (see below for details), [1:Ngrids].</p>
<pre><code> THETA_S == 3.0d0                       surface stretching parameter
 THETA_B == 0.0d0                       bottom  stretching parameter
  TCLINE == 25.0d0                      critical depth (m)
</code></pre>
<p>Mean Density and Brunt-Vaisala frequency.</p>
<pre><code>    RHO0 =  1025.0d0                    kg/m3
 BVF_BAK =  1.0d-5                      1/s2
</code></pre>
<p>If tide generating forces, set switch (T/F) to apply a 18.6-year lunar<br>
nodal correction to equilibrium tide constituents.</p>
<pre><code>  Lnodal =  T
</code></pre>
<p>Time-stamp assigned for model initialization, reference time<br>
origin for tidal forcing, and model reference time for output<br>
NetCDF units attribute.</p>
<pre><code>  DSTART =  0.0d0                       days
</code></pre>
<p>TIDE_START =  0.0d0                       days<br>
TIME_REF =  0.0d0                       yyyymmdd.dd</p>
<p>Nudging/relaxation time scales, inverse scales will be computed<br>
internally, [1:Ngrids].</p>
<pre><code>   TNUDG == 2*0.0d0                     days
   ZNUDG == 0.0d0                       days
  M2NUDG == 0.0d0                       days
  M3NUDG == 0.0d0                       days
</code></pre>
<p>Factor between passive (outflow) and active (inflow) open boundary<br>
conditions, [1:Ngrids]. If OBCFAC &gt; 1, nudging on inflow is stronger<br>
than on outflow (recommended).</p>
<pre><code>  OBCFAC == 0.0d0                       nondimensional
</code></pre>
<p>Linear equation of State parameters:</p>
<pre><code>      R0 == 1027.0d0                    kg/m3
      T0 == 14.0d0                      Celsius
      S0 == 35.0d0                      nondimensional
   TCOEF == 1.7d-4                      1/Celsius
   SCOEF == 0.0d0                       nondimensional
</code></pre>
<p>Slipperiness parameter: 1.0 (free slip) or -1.0 (no slip)</p>
<pre><code>  GAMMA2 == 1.0d0
</code></pre>
<p>Logical switches (TRUE/FALSE) to activate horizontal momentum transport<br>
point Sources/Sinks (like river runoff transport) and mass point<br>
Sources/Sinks (like volume vertical influx), [1:Ngrids].</p>
<pre><code>  LuvSrc == F                           horizontal momentum transport
   LwSrc == F                           volume vertical influx
</code></pre>
<p>Logical switches (TRUE/FALSE) to activate tracers point Sources/Sinks<br>
(like river runoff) and to specify which tracer variables to consider:<br>
[1:NAT+NPT,Ngrids].  See glossary below for details.</p>
<p>LtracerSrc == F F                         temperature, salinity, inert</p>
<p>Logical switches (TRUE/FALSE) to read and process climatology fields.<br>
See glossary below for details.</p>
<pre><code> LsshCLM == F                           sea-surface height
  Lm2CLM == F                           2D momentum
  Lm3CLM == F                           3D momentum
</code></pre>
<p>LtracerCLM == F F                         temperature, salinity, inert</p>
<p>Logical switches (TRUE/FALSE) to nudge the desired climatology field(s).<br>
If not analytical climatology fields, users need to turn ON the logical<br>
switches above to process the fields from the climatology NetCDF file<br>
that are needed for nudging. See glossary below for details.</p>
<p>LnudgeM2CLM == F                           2D momentum<br>
LnudgeM3CLM == F                           3D momentum</p>
<p>LnudgeTCLM == F F                         temperature, salinity, inert</p>
<p>Starting (DstrS) and ending (DendS) day for adjoint sensitivity forcing.<br>
DstrS must be less or equal to DendS. If both values are zero, their<br>
values are reset internally to the full range of the adjoint integration.</p>
<pre><code>   DstrS == 0.0d0                       starting day
   DendS == 0.0d0                       ending day
</code></pre>
<p>Starting and ending vertical levels of the 3D adjoint state variables<br>
whose sensitivity is required.</p>
<pre><code>   KstrS == 1                           starting level
   KendS == 1                           ending level
</code></pre>
<p>Logical switches (TRUE/FALSE) to specify the adjoint state variables<br>
whose sensitivity is required.</p>
<p>Lstate(isFsur) == F                         free-surface<br>
Lstate(isUbar) == F                         2D U-momentum<br>
Lstate(isVbar) == F                         2D V-momentum<br>
Lstate(isUvel) == F                         3D U-momentum<br>
Lstate(isVvel) == F                         3D V-momentum<br>
Lstate(isWvel) == F                         3D W-momentum</p>
<p>Lstate(isTvar) == F F                       NT tracers</p>
<p>Logical switches (TRUE/FALSE) to specify the state variables for<br>
which Forcing Singular Vectors or Stochastic Optimals is required.</p>
<p>Fstate(isFsur) == F                         free-surface<br>
Fstate(isUbar) == F                         2D U-momentum<br>
Fstate(isVbar) == F                         2D V-momentum<br>
Fstate(isUvel) == F                         3D U-momentum<br>
Fstate(isVvel) == F                         3D V-momentum<br>
Fstate(isTvar) == F F                       NT tracers</p>
<p>Fstate(isUstr) == T                         surface U-stress<br>
Fstate(isVstr) == T                         surface V-stress<br>
Fstate(isTsur) == F F                       NT surface tracers flux</p>
<p>Stochastic Optimals time decorrelation scale (days) assumed for<br>
red noise processes.</p>
<pre><code>  SO_decay == 2.0d0                     days
</code></pre>
<p>Stochastic Optimals surface forcing standard deviation for<br>
dimensionalization.</p>
<p>SO_sdev(isFsur) == 1.0d0                    free-surface<br>
SO_sdev(isUbar) == 1.0d0                    2D U-momentum<br>
SO_sdev(isVbar) == 1.0d0                    2D V-momentum<br>
SO_sdev(isUvel) == 1.0d0                    3D U-momentum<br>
SO_sdev(isVvel) == 1.0d0                    3D V-momentum<br>
SO_sdev(isTvar) == 1.0d0 1.0d0              NT tracers</p>
<p>SO_sdev(isUstr) == 1.0d0                    surface U-stress<br>
SO_sdev(isVstr) == 1.0d0                    surface V-stress<br>
SO_sdev(isTsur) == 1.0d0 1.0d0              NT surface tracers flux</p>
<p>Logical switches (TRUE/FALSE) to activate writing of fields into<br>
HISTORY output file.</p>
<p>Hout(idUvel) == T        u                  3D U-velocity<br>
Hout(idVvel) == T        v                  3D V-velocity<br>
Hout(idu3dE) == F        u_eastward         3D U-eastward  at RHO-points<br>
Hout(idv3dN) == F        v_northward        3D V-northward at RHO-points<br>
Hout(idWvel) == T        w                  3D W-velocity<br>
Hout(idOvel) == T        omega              omega vertical velocity<br>
Hout(idUbar) == T        ubar               2D U-velocity<br>
Hout(idVbar) == T        vbar               2D V-velocity<br>
Hout(idu2dE) == F        ubar_eastward      2D U-eastward  at RHO-points<br>
Hout(idv2dN) == F        vbar_northward     2D V-northward at RHO-points<br>
Hout(idFsur) == T        zeta               free-surface<br>
Hout(idBath) == T        bath               time-dependent bathymetry</p>
<p>Hout(idTvar) == T T      temp, salt         temperature and salinity</p>
<p>Hout(idpthR) == F        z_rho              time-varying depths of RHO-points<br>
Hout(idpthU) == F        z_u                time-varying depths of U-points<br>
Hout(idpthV) == F        z_v                time-varying depths of V-points<br>
Hout(idpthW) == F        z_w                time-varying depths of W-points</p>
<p>Hout(idUsms) == F        sustr              surface U-stress<br>
Hout(idVsms) == F        svstr              surface V-stress<br>
Hout(idUbms) == F        bustr              bottom U-stress<br>
Hout(idVbms) == F        bvstr              bottom V-stress</p>
<p>Hout(idUbrs) == F        bustrc             bottom U-current stress<br>
Hout(idVbrs) == F        bvstrc             bottom V-current stress<br>
Hout(idUbws) == F        bustrw             bottom U-wave stress<br>
Hout(idVbws) == F        bvstrw             bottom V-wave stress<br>
Hout(idUbcs) == F        bustrcwmax         bottom max wave-current U-stress<br>
Hout(idVbcs) == F        bvstrcwmax         bottom max wave-current V-stress</p>
<p>Hout(idUbot) == F        Ubot               bed wave orbital U-velocity<br>
Hout(idVbot) == F        Vbot               bed wave orbital V-velocity<br>
Hout(idUbur) == F        Ur                 bottom U-velocity above bed<br>
Hout(idVbvr) == F        Vr                 bottom V-velocity above bed</p>
<p>Hout(idW2xx) == F        Sxx_bar            2D radiation stress, Sxx component<br>
Hout(idW2xy) == F        Sxy_bar            2D radiation stress, Sxy component<br>
Hout(idW2yy) == F        Syy_bar            2D radiation stress, Syy component<br>
Hout(idU2rs) == F        Ubar_Rstress       2D radiation U-stress<br>
Hout(idV2rs) == F        Vbar_Rstress       2D radiation V-stress<br>
Hout(idU2Sd) == F        ubar_stokes        2D U-Stokes velocity<br>
Hout(idV2Sd) == F        vbar_stokes        2D V-Stokes velocity</p>
<p>Hout(idW3xx) == F        Sxx                3D radiation stress, Sxx component<br>
Hout(idW3xy) == F        Sxy                3D radiation stress, Sxy component<br>
Hout(idW3yy) == F        Syy                3D radiation stress, Syy component<br>
Hout(idW3zx) == F        Szx                3D radiation stress, Szx component<br>
Hout(idW3zy) == F        Szy                3D radiation stress, Szy component<br>
Hout(idU3rs) == F        u_Rstress          3D U-radiation stress<br>
Hout(idV3rs) == F        v_Rstress          3D V-radiation stress<br>
Hout(idU3Sd) == F        u_stokes           3D U-Stokes velocity<br>
Hout(idV3Sd) == F        v_stokes           3D V-Stokes velocity</p>
<p>Hout(idWamp) == F        Hwave              wave height<br>
Hout(idWlen) == F        Lwave              wave length<br>
Hout(idWdir) == F        Dwave              wave direction<br>
Hout(idWptp) == F        Pwave_top          wave surface period<br>
Hout(idWpbt) == F        Pwave_bot          wave bottom period<br>
Hout(idWorb) == F        Ub_swan            wave bottom orbital velocity<br>
Hout(idWdis) == F        Wave_dissip        wave dissipation</p>
<p>Hout(idPair) == F        Pair               surface air pressure<br>
Hout(idTair) == F        Tair               surface air temperature<br>
Hout(idUair) == F        Uair               surface U-wind component<br>
Hout(idVair) == F        Vair               surface V-wind component</p>
<p>Hout(idTsur) == F F      shflux, ssflux     surface net heat and salt flux<br>
Hout(idLhea) == F        latent             latent heat flux<br>
Hout(idShea) == F        sensible           sensible heat flux<br>
Hout(idLrad) == F        lwrad              longwave radiation flux<br>
Hout(idSrad) == F        swrad              shortwave radiation flux<br>
Hout(idEmPf) == F        EminusP            E-P flux<br>
Hout(idevap) == F        evaporation        evaporation rate<br>
Hout(idrain) == F        rain               precipitation rate</p>
<p>Hout(idDano) == F        rho                density anomaly<br>
Hout(idVvis) == F        AKv                vertical viscosity<br>
Hout(idTdif) == F        AKt                vertical T-diffusion<br>
Hout(idSdif) == F        AKs                vertical Salinity diffusion<br>
Hout(idHsbl) == F        Hsbl               depth of surface boundary layer<br>
Hout(idHbbl) == F        Hbbl               depth of bottom boundary layer<br>
Hout(idMtke) == F        tke                turbulent kinetic energy<br>
Hout(idMtls) == F        gls                turbulent length scale</p>
<p>Logical switches (TRUE/FALSE) to activate writing of extra inert passive<br>
tracers other than biological and sediment tracers into the HISTORY<br>
output file. An inert passive tracer is one that it is only advected and<br>
diffused. Other processes are ignored. These tracers include, for example,<br>
dyes, pollutants, oil spills, etc. NPT values are expected. However, these<br>
switches can be activated using compact parameter specification.</p>
<p>Hout(inert) == T        dye_01, ...        inert passive tracers</p>
<p>Logical switches (TRUE/FALSE) to activate writing of fields into<br>
QUICKSAVE output file.</p>
<p>Qout(idUvel) == F        u                  3D U-velocity<br>
Qout(idVvel) == F        v                  3D V-velocity<br>
Qout(idu3dE) == F        u_eastward         3D U-eastward  at RHO-points<br>
Qout(idv3dN) == F        v_northward        3D V-northward at RHO-points<br>
Qout(idWvel) == F        w                  3D W-velocity<br>
Qout(idOvel) == F        omega              omega vertical velocity<br>
Qout(idUbar) == T        ubar               2D U-velocity<br>
Qout(idVbar) == T        vbar               2D V-velocity<br>
Qout(idu2dE) == T        ubar_eastward      2D U-eastward  at RHO-points<br>
Qout(idv2dN) == T        vbar_northward     2D V-northward at RHO-points<br>
Qout(idFsur) == T        zeta               free-surface<br>
Qout(idBath) == T        bath               time-dependent bathymetry</p>
<p>Qout(idTvar) == F F      temp, salt         temperature and salinity</p>
<p>Qout(idUsur) == T        u_sur              surface U-velocity<br>
Qout(idVsur) == T        v_sur              surface V-velocity<br>
Qout(idUsuE) == T        u_sur_eastward     surface U-eastward  velocity<br>
Qout(idVsuN) == T        v_sur_northward    surface V-northward velocity</p>
<p>Qout(idsurT) == T T      temp_sur, salt_sur surface temperature and salinity</p>
<p>Qout(idpthR) == F        z_rho              time-varying depths of RHO-points<br>
Qout(idpthU) == F        z_u                time-varying depths of U-points<br>
Qout(idpthV) == F        z_v                time-varying depths of V-points<br>
Qout(idpthW) == F        z_w                time-varying depths of W-points</p>
<p>Qout(idUsms) == F        sustr              surface U-stress<br>
Qout(idVsms) == F        svstr              surface V-stress<br>
Qout(idUbms) == F        bustr              bottom U-stress<br>
Qout(idVbms) == F        bvstr              bottom V-stress</p>
<p>Qout(idUbrs) == F        bustrc             bottom U-current stress<br>
Qout(idVbrs) == F        bvstrc             bottom V-current stress<br>
Qout(idUbws) == F        bustrw             bottom U-wave stress<br>
Qout(idVbws) == F        bvstrw             bottom V-wave stress<br>
Qout(idUbcs) == F        bustrcwmax         bottom max wave-current U-stress<br>
Qout(idVbcs) == F        bvstrcwmax         bottom max wave-current V-stress</p>
<p>Qout(idUbot) == F        Ubot               bed wave orbital U-velocity<br>
Qout(idVbot) == F        Vbot               bed wave orbital V-velocity<br>
Qout(idUbur) == F        Ur                 bottom U-velocity above bed<br>
Qout(idVbvr) == F        Vr                 bottom V-velocity above bed</p>
<p>Qout(idW2xx) == F        Sxx_bar            2D radiation stress, Sxx component<br>
Qout(idW2xy) == F        Sxy_bar            2D radiation stress, Sxy component<br>
Qout(idW2yy) == F        Syy_bar            2D radiation stress, Syy component<br>
Qout(idU2rs) == F        Ubar_Rstress       2D radiation U-stress<br>
Qout(idV2rs) == F        Vbar_Rstress       2D radiation V-stress<br>
Qout(idU2Sd) == F        ubar_stokes        2D U-Stokes velocity<br>
Qout(idV2Sd) == F        vbar_stokes        2D V-Stokes velocity</p>
<p>Qout(idW3xx) == F        Sxx                3D radiation stress, Sxx component<br>
Qout(idW3xy) == F        Sxy                3D radiation stress, Sxy component<br>
Qout(idW3yy) == F        Syy                3D radiation stress, Syy component<br>
Qout(idW3zx) == F        Szx                3D radiation stress, Szx component<br>
Qout(idW3zy) == F        Szy                3D radiation stress, Szy component<br>
Qout(idU3rs) == F        u_Rstress          3D U-radiation stress<br>
Qout(idV3rs) == F        v_Rstress          3D V-radiation stress<br>
Qout(idU3Sd) == F        u_stokes           3D U-Stokes velocity<br>
Qout(idV3Sd) == F        v_stokes           3D V-Stokes velocity</p>
<p>Qout(idWamp) == F        Hwave              wave height<br>
Qout(idWlen) == F        Lwave              wave length<br>
Qout(idWdir) == F        Dwave              wave direction<br>
Qout(idWptp) == F        Pwave_top          wave surface period<br>
Qout(idWpbt) == F        Pwave_bot          wave bottom period<br>
Qout(idWorb) == F        Ub_swan            wave bottom orbital velocity<br>
Qout(idWdis) == F        Wave_dissip        wave dissipation</p>
<p>Qout(idPair) == F        Pair               surface air pressure<br>
Qout(idTair) == F        Tair               surface air temperature<br>
Qout(idUair) == F        Uair               surface U-wind component<br>
Qout(idVair) == F        Vair               surface V-wind component</p>
<p>Qout(idTsur) == F F      shflux, ssflux     surface net heat and salt flux<br>
Qout(idLhea) == F        latent             latent heat flux<br>
Qout(idShea) == F        sensible           sensible heat flux<br>
Qout(idLrad) == F        lwrad              longwave radiation flux<br>
Qout(idSrad) == F        swrad              shortwave radiation flux<br>
Qout(idEmPf) == F        EminusP            E-P flux<br>
Qout(idevap) == F        evaporation        evaporation rate<br>
Qout(idrain) == F        rain               precipitation rate</p>
<p>Qout(idDano) == F        rho                density anomaly<br>
Qout(idVvis) == F        AKv                vertical viscosity<br>
Qout(idTdif) == F        AKt                vertical T-diffusion<br>
Qout(idSdif) == F        AKs                vertical Salinity diffusion<br>
Qout(idHsbl) == F        Hsbl               depth of surface boundary layer<br>
Qout(idHbbl) == F        Hbbl               depth of bottom boundary layer<br>
Qout(idMtke) == F        tke                turbulent kinetic energy<br>
Qout(idMtls) == F        gls                turbulent length scale</p>
<p>Logical switches (TRUE/FALSE) to activate writing of extra inert passive<br>
tracers other than biological and sediment tracers into the QUICKSAVE<br>
output file. An inert passive tracer is one that it is only advected and<br>
diffused. Other processes are ignored. These tracers include, for example,<br>
dyes, pollutants, oil spills, etc. NPT values are expected. However, these<br>
switches can be activated using compact parameter specification.</p>
<p>Qout(inert) == F        dye_01, ...        inert passive tracers<br>
Qout(Snert) == F        dye_01_sur, ...    surface inert passive tracers</p>
<p>Logical switches (TRUE/FALSE) to activate writing of time-averaged<br>
fields into AVERAGE output file.</p>
<p>Aout(idUvel) == T        u                  3D U-velocity<br>
Aout(idVvel) == T        v                  3D V-velocity<br>
Aout(idu3dE) == F        u_eastward         3D U-eastward  at RHO-points<br>
Aout(idv3dN) == F        v_northward        3D V-northward at RHO-points<br>
Aout(idWvel) == T        w                  3D W-velocity<br>
Aout(idOvel) == T        omega              omega vertical velocity<br>
Aout(idUbar) == T        ubar               2D U-velocity<br>
Aout(idVbar) == T        vbar               2D V-velocity<br>
Aout(idu2dE) == F        ubar_eastward      2D U-eastward  at RHO-points<br>
Aout(idv2dN) == F        vbar_northward     2D V-northward at RHO-points<br>
Aout(idFsur) == T        zeta               free-surface</p>
<p>Aout(idTvar) == T T      temp, salt         temperature and salinity</p>
<p>Aout(idUsms) == F        sustr              surface U-stress<br>
Aout(idVsms) == F        svstr              surface V-stress<br>
Aout(idUbms) == F        bustr              bottom U-stress<br>
Aout(idVbms) == F        bvstr              bottom V-stress</p>
<p>Aout(idW2xx) == F        Sxx_bar            2D radiation stress, Sxx component<br>
Aout(idW2xy) == F        Sxy_bar            2D radiation stress, Sxy component<br>
Aout(idW2yy) == F        Syy_bar            2D radiation stress, Syy component<br>
Aout(idU2rs) == F        Ubar_Rstress       2D radiation U-stress<br>
Aout(idV2rs) == F        Vbar_Rstress       2D radiation V-stress<br>
Aout(idU2Sd) == F        ubar_stokes        2D U-Stokes velocity<br>
Aout(idV2Sd) == F        vbar_stokes        2D V-Stokes velocity</p>
<p>Aout(idW3xx) == F        Sxx                3D radiation stress, Sxx component<br>
Aout(idW3xy) == F        Sxy                3D radiation stress, Sxy component<br>
Aout(idW3yy) == F        Syy                3D radiation stress, Syy component<br>
Aout(idW3zx) == F        Szx                3D radiation stress, Szx component<br>
Aout(idW3zy) == F        Szy                3D radiation stress, Szy component<br>
Aout(idU3rs) == F        u_Rstress          3D U-radiation stress<br>
Aout(idV3rs) == F        v_Rstress          3D V-radiation stress<br>
Aout(idU3Sd) == F        u_stokes           3D U-Stokes velocity<br>
Aout(idV3Sd) == F        v_stokes           3D V-Stokes velocity</p>
<p>Aout(idPair) == F        Pair               surface air pressure<br>
Aout(idTair) == F        Tair               surface air temperature<br>
Aout(idUair) == F        Uair               surface U-wind component<br>
Aout(idVair) == F        Vair               surface V-wind component</p>
<p>Aout(idTsur) == F F      shflux, ssflux     surface net heat and salt flux<br>
Aout(idLhea) == F        latent             latent heat flux<br>
Aout(idShea) == F        sensible           sensible heat flux<br>
Aout(idLrad) == F        lwrad              longwave radiation flux<br>
Aout(idSrad) == F        swrad              shortwave radiation flux<br>
Aout(idevap) == F        evaporation        evaporation rate<br>
Aout(idrain) == F        rain               precipitation rate</p>
<p>Aout(idDano) == F        rho                density anomaly<br>
Aout(idVvis) == F        AKv                vertical viscosity<br>
Aout(idTdif) == F        AKt                vertical T-diffusion<br>
Aout(idSdif) == F        AKs                vertical Salinity diffusion<br>
Aout(idHsbl) == F        Hsbl               depth of surface boundary layer<br>
Aout(idHbbl) == F        Hbbl               depth of bottom boundary layer</p>
<p>Aout(id2dRV) == F        pvorticity_bar     2D relative vorticity<br>
Aout(id3dRV) == F        pvorticity         3D relative vorticity<br>
Aout(id2dPV) == F        rvorticity_bar     2D potential vorticity<br>
Aout(id3dPV) == F        rvorticity         3D potential vorticity</p>
<p>Aout(idu3dD) == F        u_detided          detided 3D U-velocity<br>
Aout(idv3dD) == F        v_detided          detided 3D V-velocity<br>
Aout(idu2dD) == F        ubar_detided       detided 2D U-velocity<br>
Aout(idv2dD) == F        vbar_detided       detided 2D V-velocity<br>
Aout(idFsuD) == F        zeta_detided       detided free-surface</p>
<p>Aout(idTrcD) == F F      temp_detided, ...  detided temperature and salinity</p>
<p>Aout(idHUav) == F        Huon               u-volume flux, Huon<br>
Aout(idHVav) == F        Hvom               v-volume flux, Hvom<br>
Aout(idUUav) == F        uu                 quadratic &lt;u<em>u&gt; term<br>
Aout(idUVav) == F        uv                 quadratic &lt;u</em>v&gt; term<br>
Aout(idVVav) == F        vv                 quadratic &lt;v<em>v&gt; term<br>
Aout(idU2av) == F        ubar2              quadratic &lt;ubar</em>ubar&gt; term<br>
Aout(idV2av) == F        vbar2              quadratic &lt;vbar<em>vbar&gt; term<br>
Aout(idZZav) == F        zeta2              quadratic &lt;zeta</em>zeta&gt; term</p>
<p>Aout(idTTav) == F F      temp_2, ...        quadratic &lt;t<em>t&gt; tracer terms<br>
Aout(idUTav) == F F      u_temp, ...        quadratic &lt;u</em>t&gt; tracer terms<br>
Aout(idVTav) == F F      v_temp, ...        quadratic &lt;v<em>t&gt; tracer terms<br>
Aout(iHUTav) == F F      Huon_temp, ...     tracer volume flux, &lt;Huon</em>t&gt;<br>
Aout(iHVTav) == F F      Hvom_temp, ...     tracer volume flux, &lt;Hvom*t&gt;</p>
<p>Logical switches (TRUE/FALSE) to activate writing of extra inert passive<br>
tracers other than biological and sediment tracers into the AVERAGE file.</p>
<p>Aout(inert) == T        dye_01, ...        inert passive tracers</p>
<p>Logical switches (TRUE/FALSE) to activate writing of time-averaged,<br>
2D momentum (ubar,vbar) diagnostic terms into DIAGNOSTIC output file.</p>
<p>Dout(M2rate) == T        ubar_accel, ...    acceleration<br>
Dout(M2pgrd) == T        ubar_prsgrd, ...   pressure gradient<br>
Dout(M2fcor) == T        ubar_cor, ...      Coriolis force<br>
Dout(M2hadv) == T        ubar_hadv, ...     horizontal total advection<br>
Dout(M2xadv) == T        ubar_xadv, ...     horizontal XI-advection<br>
Dout(M2yadv) == T        ubar_yadv, ...     horizontal ETA-advection<br>
Dout(M2hrad) == T        ubar_hrad, ...     horizontal total radiation stress<br>
Dout(M2hvis) == T        ubar_hvisc, ...    horizontal total viscosity<br>
Dout(M2xvis) == T        ubar_xvisc, ...    horizontal XI-viscosity<br>
Dout(M2yvis) == T        ubar_yvisc, ...    horizontal ETA-viscosity<br>
Dout(M2sstr) == T        ubar_sstr, ...     surface stress<br>
Dout(M2bstr) == T        ubar_bstr, ...     bottom stress</p>
<p>Logical switches (TRUE/FALSE) to activate writing of time-averaged,<br>
3D momentum (u,v) diagnostic terms into DIAGNOSTIC output file.</p>
<p>Dout(M3rate) == T        u_accel, ...       acceleration<br>
Dout(M3pgrd) == T        u_prsgrd, ...      pressure gradient<br>
Dout(M3fcor) == T        u_cor, ...         Coriolis force<br>
Dout(M3hadv) == T        u_hadv, ...        horizontal total advection<br>
Dout(M3xadv) == T        u_xadv, ...        horizontal XI-advection<br>
Dout(M3yadv) == T        u_yadv, ...        horizontal ETA-advection<br>
Dout(M3vadv) == T        u_vadv, ...        vertical advection<br>
Dout(M3hrad) == T        u_hrad, ...        horizontal total radiation stress<br>
Dout(M3vrad) == T        u_vrad, ...        vertical radiation stress<br>
Dout(M3hvis) == T        u_hvisc, ...       horizontal total viscosity<br>
Dout(M3xvis) == T        u_xvisc, ...       horizontal XI-viscosity<br>
Dout(M3yvis) == T        u_yvisc, ...       horizontal ETA-viscosity<br>
Dout(M3vvis) == T        u_vvisc, ...       vertical viscosity</p>
<p>Logical switches (TRUE/FALSE) to activate writing of time-averaged,<br>
active (temperature and salinity) and passive (inert) tracer diagnostic<br>
terms into DIAGNOSTIC output file: [1:NAT+NPT,Ngrids].</p>
<p>Dout(iTrate) == T T      temp_rate, ...     time rate of change<br>
Dout(iThadv) == T T      temp_hadv, ...     horizontal total advection<br>
Dout(iTxadv) == T T      temp_xadv, ...     horizontal XI-advection<br>
Dout(iTyadv) == T T      temp_yadv, ...     horizontal ETA-advection<br>
Dout(iTvadv) == T T      temp_vadv, ...     vertical advection<br>
Dout(iThdif) == T T      temp_hdiff, ...    horizontal total diffusion<br>
Dout(iTxdif) == T T      temp_xdiff, ...    horizontal XI-diffusion<br>
Dout(iTydif) == T T      temp_ydiff, ...    horizontal ETA-diffusion<br>
Dout(iTsdif) == T T      temp_sdiff, ...    horizontal S-diffusion<br>
Dout(iTvdif) == T T      temp_vdiff, ...    vertical diffusion</p>
<p>Generic User parameters, [1:NUSER].</p>
<pre><code>   NUSER =  0
    USER =  0.d0
</code></pre>
<p>Input and Output files processing library to use:</p>
<p>[1] Standard NetCDF-3 or NetCDF-4 library<br>
[2] Serial or Parallel I/O with Parallel-IO (PIO) library (MPI only)</p>
<pre><code> INP_LIB =  1
 OUT_LIB =  1
</code></pre>
<p>PIO library methods for reading/writing NetCDF files:</p>
<p>[0] parallel read and write of PnetCDF (CDF-5, not recommended)<br>
[1] parallel read and write of NetCDF3 (64-bit offset)<br>
[2] serial   read and write of NetCDF3 (64-bit offset)<br>
[3] parallel read and serial write of NetCDF4/HDF5<br>
[4] parallel read and write of NETCDF4/HDF5</p>
<p>PIO_METHOD =  2</p>
<p>PIO library MPI processes set-up:</p>
<p>PIO_IOTASKS =  1                  number of I/O tasks to define<br>
PIO_STRIDE =  1                  stride in the MPI-ran between I/O tasks<br>
PIO_BASE =  0                  offset for the first I/O task<br>
PIO_AGGREG =  1                  number of MPI-aggregators to use</p>
<p>PIO library rearranger methods for moving data between computational and I/O<br>
processes:</p>
<p>[1] Box rearrangement<br>
[2] Subset rearrangement</p>
<p>PIO_REARR =  1</p>
<p>PIO library rearranger flag for MPI communications between computational<br>
and I/O processes:</p>
<p>[0] Point-to-Point (low-level communications)<br>
[1] Collective (high-level grouped communications)</p>
<p>PIO_REARRCOM =  0</p>
<p>PIO library rearranger flow control direction flag for MPI communications<br>
between computational and I/O processes:</p>
<p>[0] Enable computational to I/O processes, and vice versa<br>
[2] Enable computational to I/O processes only<br>
[3] Enable I/O to computational processes only<br>
[4] Disable flow control</p>
<p>PIO_REARRDIR = 0</p>
<p>PIO rearranger options for computational to I/O processes (C2I):</p>
<p>PIO_C2I_HS = T                   Enable C2I handshake (T/F)<br>
PIO_C2I_Send = T                   Enable C2I Isends (T/F)<br>
PIO_C2I_Preq = 64                  Maximum pending C2I requests</p>
<p>PIO rearranger options for I/O to computational processes (I2C):</p>
<p>PIO_I2C_HS = T                   Enable I2C handshake (T/F)<br>
PIO_I2C_Send = T                   Enable I2C Isends (T/F)<br>
PIO_I2C_Preq = 65                  Maximum pending I2C requests</p>
<p>If OUT_LIB=1, NetCDF-4/HDF5 compression parameters for output files.</p>
<p>NC_SHUFFLE =  1                  if non-zero, turn on shuffle filter<br>
NC_DEFLATE =  1                  if non-zero, turn on deflate filter<br>
NC_DLEVEL =  1                  deflate level [0-9]</p>
<p>Input NetCDF file names, [1:Ngrids].</p>
<pre><code> GRDNAME == roms_grd.nc
 ININAME == roms_ini.nc
 ITLNAME == roms_itl.nc
 IRPNAME == roms_irp.nc
 IADNAME == roms_iad.nc
 FWDNAME == roms_fwd.nc
 ADSNAME == roms_ads.nc
</code></pre>
<p>Input adjoint forcing NetCDF filenames for computing observations<br>
impacts during the analysis-forecast cycle. If the forecast error<br>
metric is defined in state-space, then FOInameA and FOInameB should<br>
be regular adjoint forcing files just like ADSname. If the forecast<br>
error metric is defined in observation space (OBS_SPACE is activated)<br>
then the forecast is initialized OIFnameA and OIFnameB (specified in<br>
s4dvar.in input script) will have the structure of a 4D-Var observation<br>
file.</p>
<pre><code>FOInameA == roms_foi_a.nc
FOInameB == roms_foi_b.nc
</code></pre>
<p>Input NetCDF filenames for the forecasts initialized from the analysis<br>
of the current 4D-Var cycle (FCTnameA) and initialized from the analysis<br>
of the previous 4D-Var cycle (FCTnameB).</p>
<pre><code>FCTnameA == roms_fct_a.nc
FCTnameB == roms_fct_b.nc
</code></pre>
<p>Nesting grids connectivity data: contact points information. This<br>
NetCDF file is special and complex. It is currently generated using<br>
the script &quot;matlab/grid/contact.m&quot; from the Matlab repository.</p>
<pre><code> NGCNAME =  roms_ngc.nc
</code></pre>
<p>Input lateral boundary conditions file names. The USER has the option<br>
to separate the required lateral boundary variables into individual<br>
NetCDF files (NBCFILES &gt; 1), as in the input surface forcing.  Also,<br>
the USER may split input data time records into several NetCDF files<br>
(monthly, seasonal, or annual). See prologue instructions above. Use<br>
a single line per entry with a continuation () or a vertical bar (|)<br>
symbol after each entry, except the last one.</p>
<pre><code>NBCFILES == 1                           number of boundary files

 BRYNAME == roms_bry.nc
</code></pre>
<p>Input climatology file names. The USER has the option to separate the<br>
climatology variables into individual NetCDF files (NCLMFILES &gt; 1),<br>
as in the input surface forcing.  Also, the USER may split input data<br>
time records into several NetCDF files (monthly, seasonal, or annual).<br>
See prologue instructions above. Use a single line per entry with a<br>
continuation () or a vertical bar (|) symbol after each entry, except<br>
the last one.</p>
<p>NCLMFILES == 1                           number of climatology files</p>
<pre><code> CLMNAME == roms_clm.nc
</code></pre>
<p>Input climatology nudging coefficients file name.</p>
<pre><code> NUDNAME == roms_nud.nc
</code></pre>
<p>Input Sources/Sinks forcing (like river runoff) file name.</p>
<pre><code> SSFNAME == roms_rivers.nc
</code></pre>
<p>Input tidal forcing file name.</p>
<pre><code>TIDENAME == roms_tides.nc
</code></pre>
<p>Input forcing NetCDF file name(s).</p>
<p>The USER has the option to enter several sets of file names for each<br>
nested grid. For example, the USER may have different data for the<br>
wind products, heat fluxes, etc. Alternatively, if the all the forcing<br>
files are the same for nesting and the data is in its native resolution,<br>
we could enter only one set of files names and ROMS will replicate those<br>
files internally to the remaining grids using the plural KEYWORD protocol.</p>
<p>The model will scan the files and will read the needed data from the first<br>
file in the list containing the forcing field. Therefore, the order of the<br>
filenames is critical. If using multiple forcing files per grid, first<br>
enter all the file names for grid one followed by two, and so on.  It is<br>
also possible to split input data time records into several NetCDF files<br>
(see Prolog instructions above). Use a single line per entry with a<br>
continuation () or a vertical bar (|) symbol after each entry, except<br>
the last one.</p>
<pre><code> NFFILES == 1                           number of unique forcing files

 FRCNAME == roms_frc.nc                forcing file 1, grid 1
</code></pre>
<p>Output NetCDF file names, [1:Ngrids].</p>
<pre><code> DAINAME == roms_dai.nc
 GSTNAME == roms_gst.nc
 RSTNAME == roms_rst.nc
 HISNAME == roms_his.nc
 QCKNAME == roms_qck.nc
 TLMNAME == roms_tlm.nc
 TLFNAME == roms_tlf.nc
 ADJNAME == roms_adj.nc
 AVGNAME == roms_avg.nc
 HARNAME == roms_har.nc
 DIANAME == roms_dia.nc
 STANAME == roms_sta.nc
 FLTNAME == roms_flt.nc
</code></pre>
<p>Input ASCII parameter filenames.</p>
<pre><code> APARNAM =  ROMS/External/s4dvar.in
 SPOSNAM =  ROMS/External/stations.in
 FPOSNAM =  ROMS/External/floats.in
 BPARNAM =  ROMS/External/bio_Fennel.in
 SPARNAM =  ROMS/External/sediment.in
 USRNAME =  ROMS/External/MyFile.dat
</code></pre>
<h1 id="glossary">GLOSSARY:</h1>
<hr>
<h2 id="application-title-string-with-a-maximum-of-80-characters-andc-preprocessing-flag">Application title (string with a maximum of 80 characters) and<br>
C-preprocessing flag.</h2>
<p>TITLE        Application title.</p>
<p>MyAppCPP     Application C-preprocessing option.</p>
<hr>
<h2 id="variable-information-filename-string-with-a-maximum-of-256-characters">Variable information filename (string with a maximum of 256 characters).</h2>
<p>VARNAME      Input/Output variable information filename.  This file needs to<br>
be processed first so all information arrays and indices can<br>
be initialized properly in &quot;mod_ncparam.F&quot;.</p>
<hr>
<h2 id="nested-grid-parameters-processing-order-of-these-parameters-is-important">Nested grid parameters (processing order of these parameters is important).</h2>
<p>Ngrids       Number of nested grids. It needs to be read before all other<br>
parameters in order to allocate all model variables.</p>
<p>NestLayers   Number of grid nesting layers. It is used to allow applications<br>
with both composite and refinement grid combinations, as shown<br>
in WikiROMS diagrams for the Refinement and Partial Boundary<br>
Composite Sub-Classes. See,</p>
<pre><code>            https://www.myroms.org/wiki/index.php/Nested_Grids

            In non-nesting applications, set NestLayers = 1.
</code></pre>
<p>GridsInLayer Number of grids in each nested layer, a vector of size<br>
[1:NestLayers]. Notice that,</p>
<pre><code>            SUM(GridsInLayer)    = Ngrids
            LENGHT(GridsInLayer) = NestLayers

            The order of grids and nesting layers is extremely important.
            It determines the order of the sequential solution at every
            sub-timestep.  See WikiROMS nesting Sub-Classes diagrams.

            In non-nesting applications, set GridsInLayer = 1.

            NOTE:  In main3d, we use these parameters to determine which
            ====   grid index, ng, to solve when calling the routines of
                   the computational kernel:

              NEST_LAYER : DO nl=1,NestLayers
                ...
                STEP_LOOP : DO istep=1,Nsteps
                  ...
                  DO ig=1,GridsInLayer(nl)
                    ng=GridNumber(ig,nl)
                    ...
                  END DO
                  ...
                END DO STEP_LOOP
              END DO NEST_LAYER

            Here, the grid order &quot;ng&quot; for the computations is determined
            from array &quot;GridNumber&quot;, which is computed at initialization
            in &quot;read_phypar.F&quot;. It can be computed on the fly as:

              ng=Ngrids+1
              DO j=NestLayers,nl,-1
                DO i=GridsInLayer(j),1,-1
                  ng=ng-1
                  IF ((j.eq.nl).and.(i.eq.ig)) EXIT
                END DO
              END DO

            but it is too inefficient. This information is provided here
            to help you configure the order of nested grids.
</code></pre>
<hr>
<h2 id="grid-dimension-parameters">Grid dimension parameters.</h2>
<p>These parameters are very important since they determine the grid of the<br>
application to solve. They need to be read first in order to dynamically<br>
allocate all model variables.</p>
<p>WARNING: It is trivial and possible to change these dimension parameters in<br>
-------  idealized applications via analytical expressions.  However, in<br>
realistic applications any change to these parameters requires redoing all<br>
input NetCDF files.</p>
<p>Lm           Number of INTERIOR grid RHO-points in the XI-direction for<br>
each nested grid, [1:Ngrids]. If using NetCDF files as<br>
input, Lm=xi_rho-2 where &quot;xi_rho&quot; is the NetCDF file<br>
dimension of RHO-points. Recall that all RHO-point<br>
variables have a computational I-range of [0:Lm+1].</p>
<p>Mm           Number of INTERIOR grid RHO-points in the ETA-direction for<br>
each nested grid, [1:Ngrids]. If using NetCDF files as<br>
input, Mm=eta_rho-2 where &quot;eta_rho&quot; is the NetCDF file<br>
dimension of RHO-points. Recall that all RHO-point<br>
variables have a computational J-range of [0:Mm+1].</p>
<p>N            Number of vertical terrain-following levels at RHO-points,<br>
[1:Ngrids].</p>
<p>Nbed         Number of sediment bed layers, [1:Ngrids]. This parameter<br>
is only relevant if CPP option SEDIMENT is activated.</p>
<pre><code>            Mm+1  ___________________                _______  Kw = N
                 |                   |              |       |
              Mm |   _____________   |              |       | Kr = N
                 |  |             |  |              |_______|
                 |  |             |  |              |       |
              Jr |  |             |  |              |       |
                 |  |             |  |              |_______|
                 |  |             |  |              |       |
               1 |  |_____________|  |              |       |
                 |                   |              |_______|
               0 |___________________|              |       |
                          Ir                        |       | 1
                 0  1            Lm  Lm+1    h(i,j) |_______|
                                                    ::::::::: 0
                                                    :::::::::
                                                    ::::::::: Nbed-1
                                                    ::::::::: Nbed
</code></pre>
<p>NAT          Number of active tracer type variables. Usually, NAT=2 for<br>
potential temperature and salinity.</p>
<p>NPT          Number of inert (dyes, age, etc) passive tracer type variables<br>
to advect and diffuse only. This parameter is only relevant<br>
if CPP option T_PASSIVE is activated.</p>
<p>NCS          Number of cohesive (mud) sediment tracer type variables. This<br>
parameter is only relevant if CPP option SEDIMENT is<br>
activated.</p>
<p>NNS          Number of non-cohesive (sand) sediment tracer type variables.<br>
This parameter is only relevant if CPP option SEDIMENT is<br>
activated.</p>
<pre><code>            The total number of sediment tracers is NST=NCS+NNS.  Notice
            that NST must be greater than zero (NST&gt;0).
</code></pre>
<hr>
<h2 id="domain-tile-partition-parameters">Domain tile partition parameters.</h2>
<p>Model tile decomposition parameters for serial and parallel configurations<br>
which are used to determine tile horizontal range indices (Istr,Iend and<br>
Jstr,Jend). In some computers, it is advantageous to have tile partitions<br>
in serial applications.</p>
<p>NtileI       Number of domain partitions in the I-direction (XI-coordinate).<br>
It must be equal to or greater than one.</p>
<p>NtileJ       Number of domain partitions in the J-direction (ETA-coordinate).<br>
It must be equal to or greater than one.</p>
<p>WARNING:     In shared-memory (OpenMP), the product of NtileI and NtileJ must<br>
be a MULTIPLE of the number of parallel threads specified with<br>
the OpenMP environmental variable OMP_NUM_THREADS.</p>
<pre><code>          In distributed-memory (MPI), the product of NtileI and NtileJ
          must be EQUAL to the number of parallel nodes specified during
          execution with the &quot;mprun&quot; or &quot;mpirun&quot; command.
</code></pre>
<hr>
<h2 id="tracer-advection-scheme">Tracer advection scheme</h2>
<p>It is more advantageous to set the horizontal and vertical advection schemes<br>
for each tracer with switches instead of a single CPP flag for all of them.<br>
Positive-definite and monotonic algorithms (i.e., MPDATA and HSIMT) are<br>
appropriate and useful for positive fields like salinity, inert, biological,<br>
and sediment tracers.  However, since the temperature has a dynamic range<br>
with negative and positive values in the ocean, other advection schemes are<br>
more appropriate.</p>
<p>Currently, the following tracer advection schemes are available and are<br>
activated using the associated Keyword:</p>
<p>Keyword    Advection Algorithm</p>
<p>A4         4th-order Akima (horizontal/vertical)<br>
C2         2nd-order centered differences (horizontal/vertical)<br>
C4         4th-order centered differences (horizontal/vertical)<br>
HSIMT      3th-order HSIMT with TVD limiter (horizontal/vertical)<br>
MPDATA     recursive flux corrected MPDATA (horizontal/vertical)<br>
SPLINES    parabolic splines reconstruction (only vertical)<br>
SU3        split third-order upstream (horizontal/vertical)<br>
U3         3rd-order upstresm-bias (only horizontal)</p>
<p>The user has the option of specifying the full Keyword or the first<br>
two letters, regardless if using uppercase or lowercase.</p>
<p>If using either HSIMT (Wu and Zhu, 2010) or MPDATA (Margolin and<br>
Smolarkiewicz, 1998) options, the user needs to set the same scheme<br>
for both horizontal and vertical advection to preserve monotonicity.</p>
<p>Hadvection     Horizontal advection for each active (temperature and<br>
salinity) and inert tracers, [1:NAT+NPT,Ngrids]<br>
values are expected.</p>
<p>Vadvection     Vertical advection for each active (temperature and<br>
salinity) and inert tracers, [1:NAT+NPT,Ngrids]<br>
values are expected.</p>
<p>ad_Hadvection  Horizontal advection for each active (temperature and<br>
salinity) and inert tracers in the adjoint-based<br>
algorithms, [1:NAT+NPT,Ngrids] values are expected.</p>
<p>ad_Vadvection  Vertical advection for each active (temperature and<br>
salinity) and inert tracers in the adjoint-based<br>
algorithms, [1:NAT+NPT,Ngrids] values are expected.</p>
<p>Examples:</p>
<p>Hadvection == A4       \                      temperature<br>
MPDATA   \                      salinity<br>
HSIMT    \                      dye_01, inert(1)<br>
HSIMT                           dy2_02, inert(2)</p>
<p>Vadvection == A4       \                      temperature<br>
MPDATA   \                      salinity<br>
HSIMT    \                      dye_01, inert(1)<br>
HSIMT                           dye_02, inert(2)</p>
<p>or in nested applications</p>
<p>Hadvection == U3       \                      temperature, Grid 1<br>
HSIMT    \                      salinity,    Grid 1<br>
U3       \                      temperature, Grid 2<br>
HSIMT    \                      salinity,    Grid 2<br>
U3       \                      temperature, Grid 3<br>
HSIMT                           salinity,    Grid 3</p>
<p>Vadvection == C4       \                      temperature, Grid 1<br>
HSIMT    \                      salinity,    Grid 1<br>
C4       \                      temperature, Grid 2<br>
HSIMT    \                      salinity,    Grid 2<br>
C4       \                      temperature, Grid 3<br>
HSIMT                           salinity,    Grid 3</p>
<hr>
<h2 id="lateral-boundary-conditions-parameters">Lateral boundary conditions parameters.</h2>
<p>The lateral boundary conditions are now specified with logical switches<br>
instead of CPP flags to allow nested grid configurations. Their values are<br>
loaded into structured array:</p>
<pre><code>LBC(1:4, nLBCvar, Ngrids)
</code></pre>
<p>where 1:4 are the number of boundary edges, nLBCvar are the number of LBC<br>
state variables, and Ngrids is the number of nested grids. For Example, to<br>
apply gradient boundary conditions we use:</p>
<pre><code>LBC(iwest,  isFsur, ng) % gradient
LBC(ieast,  ...   , ng) % gradient
LBC(isouth, ...   , ng) % gradient
LBC(inorth, ...   , ng) % gradient
</code></pre>
<p>The lateral boundary conditions are entered with a keyword. This keyword<br>
is case insensitive and usually has three characters. However, it is<br>
possible to have compound keywords, if applicable. For example, the<br>
keyword &quot;RadNud&quot; implies radiation boundary condition with nudging. This<br>
combination is usually used in active/passive radiation conditions.</p>
<p>Keyword    Lateral Boundary Condition Type</p>
<p>Cha        Chapman_implicit (free-surface only)<br>
Che        Chapman_explicit (free-surface only)<br>
Cla        Clamped<br>
Clo        Closed<br>
Fla        Flather (2D momentum only)             <em><strong><strong>N</strong></strong></em>     j=Mm<br>
Gra        Gradient                              |     4     |<br>
Nes        Nested (refinement only)              |           |<br>
Nud        Nudging                             1 W           E 3<br>
Per        Periodic                              |           |<br>
Rad        Radiation                             |<em><strong><strong>S</strong></strong></em>|<br>
Red        Reduced Physics (2D momentum only)          2          j=1<br>
Shc        Shchepetkin (2D momentum only)       i=1         i=Lm</p>
<p>LBC(isFsur) Free-surface,  [1:4, Ngrids] values are expected.<br>
LBC(isUbar) 2D U-momentum, [1:4, Ngrids] values are expected.<br>
LBC(isVbar) 2D V-momentum, [1:4, Ngrids] values are expected.<br>
LBC(isUvel) 3D U-momentum, [1:4, Ngrids] values are expected.<br>
LBC(isVvel) 3D V-momentum, [1:4, Ngrids] values are expected.<br>
LBC(isMtke) Mixing TKE,    [1:4, Ngrids] values are expected.<br>
LBC(isTvar) Tracers,       [1:4, 1:NAT+NPT, Ngrids] values are expected.</p>
<p>Similarly, the adjoint-based algorithms (ADM, TLM, RPM) can have different<br>
lateral boundary conditions keywords:</p>
<p>ad_LBC(isFsur) Free-surface,  [1:4, Ngrids] values are expected.<br>
ad_LBC(isUbar) 2D U-momentum, [1:4, Ngrids] values are expected.<br>
ad_LBC(isVbar) 2D V-momentum, [1:4, Ngrids] values are expected.<br>
ad_LBC(isUvel) 3D U-momentum, [1:4, Ngrids] values are expected.<br>
ad_LBC(isVvel) 3D V-momentum, [1:4, Ngrids] values are expected.<br>
ad_LBC(isMtke) Mixing TKE,    [1:4, Ngrids] values are expected.<br>
ad_LBC(isTvar) Tracers,       [1:4, 1:NAT+NPT, Ngrids] values are expected.</p>
<p>Lateral open boundary edge volume conservation switch for nonlinear model<br>
and adjoint-based algorithm. Usually activated with radiation boundary<br>
conditions to enforce global mass conservation. Notice that these switches<br>
should not be activated if tidal forcing is enabled, [1:Ngrids] values are<br>
expected.</p>
<p>VolCons(west)       Western  boundary volume conservation switch.<br>
VolCons(east)       Eastern  boundary volume conservation switch.<br>
VolCons(south)      Southern boundary volume conservation switch.<br>
VolCons(north)      Northern boundary volume conservation switch.</p>
<p>ad_VolCons(west)    Western  boundary volume conservation switch.<br>
ad_VolCons(east)    Eastern  boundary volume conservation switch.<br>
ad_VolCons(south)   Southern boundary volume conservation switch.<br>
ad_VolCons(north)   Northern boundary volume conservation switch.</p>
<hr>
<h2 id="timestepping-parameters">Timestepping parameters.</h2>
<p>NTIMES       Total number of timesteps in current run.  If 3D configuration,<br>
NTIMES is the total of baroclinic timesteps.  If only 2D<br>
configuration, NTIMES is the total of barotropic timesteps.</p>
<p>DT           TimeStep size in seconds.  If 3D configuration, DT is the<br>
size of the baroclinic timestep.  If only 2D configuration,<br>
DT is the size of the barotropic timestep.</p>
<p>NDTFAST      Number of barotropic timesteps between each baroclinic time<br>
step. If only 2D configuration, NDTFAST should be unity since<br>
there is no need to split timestepping.</p>
<p>NTIMES_ANA   Total number of timesteps for computing observations impacts<br>
interval during the analysis cycle. It is only used when<br>
RBL4DVAR_FCT_SENSITIVITY is activated.</p>
<p>NTIMES_FCT   Total number of timesteps for computing observations impacts<br>
interval during the forecast cycle. It is only used when<br>
RBL4DVAR_FCT_SENSITIVITY is activated.</p>
<hr>
<h2 id="model-iteration-loops-parameters">Model iteration loops parameters.</h2>
<p>ERstr        Starting ensemble run (perturbation or iteration) number.</p>
<p>ERend        Ending   ensemble run (perturbation or iteration) number.</p>
<p>Nouter       Maximum number of 4DVAR outer loop iterations.</p>
<p>Ninner       Maximum number of 4DVAR inner loop iterations.</p>
<p>Nsaddle      Number of kernel trajectory intervals for the solution of the<br>
Saddle-Point 4D-Var (SP4DVAR). It is used to accelerate<br>
4D-Var by parallelizing the inner loops in time. The tangent<br>
linear and adjoint models are time-stepped concurrently over<br>
the short time integration windows.  Make sure that</p>
<pre><code>              MOD(NTIMES/NHIS, Nsaddle) = 0

            for legal computations.
</code></pre>
<p>Nintervals   Number of time interval divisions for Stochastic Optimals<br>
computations. It must be a multiple of NTIMES. The tangent<br>
linear model (TLM) and the adjoint model (ADM) are integrated<br>
forward and backward at different intervals.  For example,<br>
if Nintervals=3,</p>
<pre><code>          1               NTIMES/3         2*NTIMES/3           NTIMES
          +..................+..................+..................+
          &lt;========================================================&gt; (1)
                             &lt;=====================================&gt; (2)
                                                &lt;==================&gt; (3)

          In the first iteration (1), the TLM is integrated forward from
          1 to NTIMES and the ADM is integrated backward from NTIMES to 1.
          In the second iteration (2), the TLM is integrated forward from
          NTIMES/3 to NTIMES and the ADM is integrated backward from
          NTIMES to NTIMES/3. And so on.
</code></pre>
<hr>
<h2 id="eigenproblem-parameters">Eigenproblem parameters.</h2>
<p>NEV          Number of eigenvalues to compute for the Lanczos/Arnoldi<br>
problem.  Notice that the model memory requirement increases<br>
substantially as NEV increases.  The GST requires NEV+1<br>
copies of the model state vector.  The memory requirements<br>
are decreased in distributed-memory applications.</p>
<p>NCV          Number of eigenvectors to compute for the Lanczos/Arnoldi<br>
problem. NCV must be greater than NEV.</p>
<p>At present, there is no apriori analysis to guide the selection of NCV<br>
relative to NEV.  The only formal requirement is that NCV &gt; NEV. However<br>
in optimal perturbations, it is recommended to have NCV greater than or<br>
equal to 2<em>NEV. In Finite Time Eigenmodes (FTE) and Adjoint Finite Time<br>
Eigenmodes (AFTE) the requirement is to have NCV greater than or equal to<br>
2</em>NEV+1.</p>
<p>The efficiency of calculations depends critically on the combination of<br>
NEV and NCV.  If NEV is large (greater than 10 say), you can use NCV=2<em>NEV+1<br>
but for NEV small (less than 6) it will be inefficient to use NCV=2</em>NEV+1.<br>
In complicated applications, you can start with NEV=2 and NCV=10. Otherwise,<br>
it will iterate for a very long time.</p>
<hr>
<h2 id="inputoutput-parameters">Input/Output parameters.</h2>
<p>NRREC        Switch to indicate re-start from a previous solution.  Use<br>
NRREC=0 for new solutions. In a re-start solution, NRREC<br>
is the time index of the re-start NetCDF file assigned for<br>
initialization.  If NRREC is negative (say NRREC=-1), the<br>
model will re-start from the most recent time record. That<br>
is, the initialization record is assigned internally.<br>
Notice that it is also possible to re-start from a history<br>
or time-averaged NetCDF file.  If a history file is used<br>
for re-start, it must contains all the necessary primitive<br>
variables at all levels.</p>
<p>LcycleRST    Logical switch (T/F) used to recycle time records in output<br>
restart file.  If TRUE,  only the latest two re-start time<br>
records are maintained.  If FALSE, all re-start fields are<br>
saved every NRST timesteps without recycling.  The restart<br>
fields are written at all levels in double precision.</p>
<p>NRST         Number of timesteps between the writing of re-start fields.<br>
Set NRST=0 to suppress writing of RESTART file.</p>
<p>NSTA         Number of timesteps between writing data into STATIONS file.<br>
Station data is written at all levels.</p>
<p>NFLT         Number of timesteps between writing data into FLOATS file.</p>
<p>NINFO        Number of timesteps between the print of single line information<br>
to standard output.  It also determines the interval between<br>
computation of global energy diagnostics.</p>
<hr>
<h2 id="output-history-quicksave-average-and-diagnostic-files-parameters">Output HISTORY, QUICKSAVE, AVERAGE and DIAGNOSTIC files parameters.</h2>
<p>Notice that it is possible to have two types of output NetCDF files for<br>
instantaneous fields: HISTORY and QUICKSAVE. The QUICKSAVE file can be used<br>
for writing fewer fields at shorter time intervals. For example, the User<br>
may just write 2D and surface fields frequently (hourly) to reduce file<br>
size and to time resolve fast dynamics. In conjunction, the User may write<br>
full HISTORY fields infrequently (daily, weekly, etc) to avoid creating<br>
large output files. This gives a lot of flexibility to manage ROMS output.</p>
<p>LDEFOUT      Logical switch (T/F) used to create new output files when<br>
initializing from a re-start file, abs(NRREC) &gt; 0.  If TRUE<br>
and applicable, a new HISTORY, QUICKSAVE, AVERAGE, DIAGNOSTIC<br>
and STATIONS files are created during the initialization<br>
stage. If FALSE and applicable, data is appended to existing<br>
HISTORY, QUICKSAVE, AVERAGE, DIAGNOSTIC and STATIONS files.<br>
See also parameters NDEFHIS, NDEFQCK, NDEFAVG and NDEFDIA<br>
below.</p>
<p>NHIS         Number of timesteps between writing fields into the HISTORY<br>
file. Set NHIS=0 to suppress writing of HISTORY file.</p>
<p>NDEFHIS      Number of timesteps between the creation of new HISTORY file.<br>
If NDEFHIS=0, the model will only process one HISTORY file.<br>
This feature is useful for extended simulations when HISTORY<br>
file get too large; it creates a new file every NDEFHIS<br>
timesteps.</p>
<p>NQCK         Number of timesteps between writing fields into QUICKSAVE file.<br>
Set NQCK=0 to suppress writing of QUICKSAVE file.</p>
<p>NDEFQCK      Number of timesteps between the creation of new QUICKSAVE file.<br>
If NDEFQCK=0, the model will only process one QUICKSAVE file.<br>
This feature is useful for extended simulations when QUICKSAVE<br>
file get too large; it creates a new file every NDEFQCK<br>
timesteps.</p>
<p>NTSAVG       Starting timestep for the accumulation of output time-averaged<br>
data.</p>
<p>NAVG         Number of timesteps between writing time-averaged data<br>
into AVERAGE file.  Averaged date is written for all fields.<br>
Set NAVG=0 to suppress writing of AVERAGE file.</p>
<p>NDEFAVG      Number of timesteps between the creation of new AVERAGE<br>
file.  If NDEFAVG=0, the model will only process one AVERAGE<br>
file.  This feature is useful for extended simulations when<br>
AVERAGE file get too large; it creates a new file every<br>
NDEFAVG timesteps.</p>
<p>NTSDIA       Starting timestep for the accumulation of output time-averaged<br>
diagnostics data.</p>
<p>NDIA         Number of timesteps between writing time-averaged diagnostics<br>
data into DIAGNOSTIC file.  Averaged date is written for all<br>
fields. Set NDIA=0 to suppress writing of DIAGNOSTIC file.</p>
<p>NDEFDIA      Number of timesteps between the creation of new time-averaged<br>
diagnostics file.  If NDEFDIA=0, the model will only process<br>
one DIAGNOSTICS file.  This feature is useful for long<br>
simulations when DIAGNOSTIC file get too large; it creates<br>
a new file every NDEFDIA timesteps.</p>
<hr>
<h2 id="output-tangent-linear-and-adjoint-model-parameters">Output tangent linear and adjoint model parameters.</h2>
<p>LcycleTLM    Logical switch (T/F) used to recycle time records in output<br>
tangent linear file.  If TRUE, only the latest two time<br>
records are maintained.  If FALSE, all tangent linear fields<br>
are saved every NTLM timesteps without recycling.</p>
<p>NTLM         Number of timesteps between writing fields into tangent linear<br>
model file.</p>
<p>NDEFTLM      Number of timesteps between the creation of new tangent linear<br>
file. If NDEFTLM=0, the model will only process one tangent<br>
linear file. This feature is useful for extended simulations<br>
when output NetCDF files get too large; it creates a new file<br>
every NDEFTLM timesteps.</p>
<p>LcycleADJ    Logical switch (T/F) used to recycle time records in output<br>
adjoint file.  If TRUE, only the latest two time records are<br>
maintained.  If FALSE, all tangent linear fields are saved<br>
every NADJ timesteps without recycling.</p>
<p>NADJ         Number of timesteps between writing fields into the adjoint<br>
model file.</p>
<p>NDEFADJ      Number of timesteps between the creation of the new adjoint<br>
file. If NDEFADJ=0, the model will only process one adjoint<br>
file. This feature is useful for extensive simulations when<br>
the output NetCDF files get too large; it creates a new file<br>
every NDEFADJ timesteps.</p>
<p>NSFF         Number of timesteps between 4DVAR adjustment of surface forcing<br>
fluxes. In strong constraint 4DVAR, it is possible to adjust<br>
surface forcing at other time intervals in addition to initial<br>
time.  This parameter is used to store the appropriate number<br>
of surface forcing records in the output history NetCDF files:<br>
1+NTIMES/NSFF records. NSFF must be a factor of NTIMES or<br>
greater than NTIMES. If NSFF &gt; NTIMES, only one record is<br>
stored in the NetCDF files and the adjustment is for constant<br>
forcing with constant correction. This parameter is only<br>
relevant in 4DVAR when activating either ADJUST_STFLUX or<br>
ADJUST_WSTRESS.</p>
<p>NOBC         Number of timesteps between 4DVAR adjustment of open boundary<br>
fields. In strong constraint 4DVAR, it is possible to adjust<br>
open boundaries at other time intervals in addition to initial<br>
time.  This parameter is used to store the appropriate number<br>
of open boundary records in the output history NetCDF files:<br>
1+NTIMES/NOBC records. NOBC must be a factor of NTIMES or<br>
greater than NTIMES. If NOBC &gt; NTIMES, only one record is<br>
stored in the NetCDF files and the adjustment is for constant<br>
forcing with constant correction. This parameter is only<br>
relevant in 4DVAR when activating ADJUST_BOUNDARY.</p>
<hr>
<h2 id="generalized-stability-theory-gst-analysis-parameters">Generalized Stability Theory (GST) analysis parameters.</h2>
<p>LmultiGST    Logical switch (TRUE/FALSE) to write out one GST analysis<br>
eigenvector per history file.</p>
<p>LrstGST      Logical switch (TRUE/FALSE) to restart GST analysis. If TRUE,<br>
the check pointing data is read in from the GST restart NetCDF<br>
file.  If FALSE and applicable, the checkpointing GST data is<br>
saved and overwritten every NGST iterations of the algorithm.</p>
<p>MaxIterGST   Maximum number of GST algorithm iterations.</p>
<p>NGST         Number of GST iterations between storing of check pointing<br>
data into NetCDF file. The restart data is always saved if<br>
MaxIterGST is reached without convergence. It is also saved<br>
when convergence is achieved. It is always a good idea to<br>
save the checkpointing data at regular intervals so there<br>
is a mechanism to recover from an unexpected interruption<br>
in this costly computation. The check pointing data can<br>
be used also to recompute the Ritz vectors by changing some<br>
of the parameters, like convergence criteria (Ritz_tol)<br>
and number of Arnoldi iterations (iparam(3)).</p>
<p>Ritz_tol     Relative accuracy of the Ritz values computed in the GST<br>
analysis.</p>
<hr>
<h2 id="harmonicbiharmonic-horizontal-diffusion-for-active-tracers-and-viscosityfor-momentum">Harmonic/Biharmonic horizontal diffusion for active tracers and viscosity<br>
for momentum.</h2>
<p>TNU2         Nonlinear model lateral, harmonic, constant, mixing<br>
coefficient (m2/s) for active (NAT) and inert (NPT) tracer<br>
variables. If variable horizontal diffusion is activated,<br>
TNU2 is the mixing coefficient for the largest grid-cell<br>
in the domain.</p>
<p>TNU4         Nonlinear model lateral, biharmonic, constant, mixing<br>
coefficient (m4/s) for active (NAT) and inert (NPT) tracer<br>
variables. If variable horizontal diffusion is activated,<br>
TNU4 is the mixing coefficient for the largest grid-cell<br>
in the domain.</p>
<p>ad_TNU2      Adjoint-based algorithms lateral, harmonic, constant, mixing<br>
coefficient (m2/s) for active (NAT) and inert (NPT) tracer<br>
variables. If variable horizontal diffusion is activated,<br>
ad_TNU2 is the mixing coefficient for the largest grid-cell<br>
in the domain. In some applications, a larger value than<br>
that used in the nonlinear model (basic state) is necessary<br>
for stability.</p>
<p>ad_TNU4      Adjoint-based algorithms lateral, biharmonic, constant, mixing<br>
coefficient (m4/s) for active (NAT) and inert (NPT) tracer<br>
variables. If variable horizontal diffusion is activated,<br>
ad_TNU4 is the mixing coefficient for the largest grid-cell<br>
in the domain. In some applications, a larger value than<br>
that used in the nonlinear model (basic state) is necessary<br>
for stability.</p>
<p>VISC2        Nonlinear model lateral, harmonic, constant, mixing<br>
coefficient (m2/s) for momentum. If variable horizontal<br>
viscosity is activated, UVNU2 is the mixing coefficient<br>
for the largest grid-cell in the domain.</p>
<p>VISC4        Nonlinear model lateral, biharmonic, constant mixing<br>
coefficient (m4/s) for momentum. If variable horizontal<br>
viscosity is activated, UVNU4 is the mixing coefficient<br>
for the largest grid-cell in the domain.</p>
<p>ad_VISC2     Adjoint-based algorithms lateral, harmonic, constant, mixing<br>
coefficient (m2/s) for momentum. If variable horizontal<br>
viscosity is activated, ad_UVNU2 is the mixing coefficient<br>
for the largest grid-cell in the domain. In some applications,<br>
a larger value than that used in the nonlinear model (basic<br>
state) is necessary for stability.</p>
<p>ad_VISC4     Adjoint-based algorithms lateral, biharmonic, constant mixing<br>
coefficient (m4/s) for momentum. If variable horizontal<br>
viscosity is activated, ad_UVNU4 is the mixing coefficient<br>
for the largest grid-cell in the domain. In some applications,<br>
a larger value than that used in the nonlinear model (basic<br>
state) is necessary for stability.</p>
<hr>
<h2 id="switches-to-activate-sponge-areas-with-enhanced-horizontal-mixing">Switches to activate sponge areas with enhanced horizontal mixing.</h2>
<p>LuvSponge     Logical switch (TRUE/FALSE) to increase/decrease horizontal<br>
viscosity in specific areas of the domain. It can be used<br>
to specify sponge areas with larger horizontal mixing<br>
coefficients for damping of high frequency noise due to<br>
open boundary conditions or nesting. The CPP option SPONGE<br>
is now deprecated and replaced with this switch to facilitate<br>
or not sponge areas over a particular nested grid.</p>
<pre><code>             The horizontal mixing distribution is specified in
             &quot;ini_hmixcoef.F&quot; as:

               visc2_r(i,j) = visc_factor(i,j) * visc2_r(i,j)
               visc4_r(i,j) = visc_factor(i,j) * visc4_r(i,j)

             The variable &quot;visc_factor&quot; can be read from the grid
             NetCDF file. Alternately, the horizontal viscosity in the
             sponge area can be set-up with analytical functions in
             &quot;ana_sponge.h&quot; using CPP ANA_SPONGE when the switch
             &quot;LuvSponge&quot; is turned ON for a particular grid.
</code></pre>
<p>LtracerSponge Logical switch (TRUE/FALSE) to increase/decrease horizontal<br>
diffusivity in specific areas of the domain. It can be used<br>
to specify sponge areas with larger horizontal mixing<br>
coefficients for damping of high frequency noise due to<br>
open boundary conditions or nesting. The CPP option SPONGE<br>
is now deprecated and replaced with this switch to facilitate<br>
or not sponge areas over a particular nested grid.</p>
<pre><code>             The horizontal mixing distribution is specified in
             &quot;ini_hmixcoef.F&quot; as:

               diff2(i,j,itrc) = diff_factor(i,j) * diff2(i,j,itrc)
               diff4(i,j,itrc) = diff_factor(i,j) * diff4(i,j,itrc)

             The variable &quot;diff_factor&quot; can be read from the grid
             NetCDF file. Alternately, the horizontal viscosity in the
             sponge area can be set-up with analytical functions in
             &quot;ana_sponge.h&quot; using CPP ANA_SPONGE when the switch
             &quot;LuvSponge&quot; is turned ON for a particular grid.
</code></pre>
<hr>
<h2 id="vertical-mixing-coefficients-for-active-tracers">Vertical mixing coefficients for active tracers.</h2>
<p>AKT_BAK      Background vertical mixing coefficient (m2/s) for active<br>
(NAT) and inert (NPT) tracer variables.</p>
<p>AKT_LIMIT    Upper threshold values to limit vertical diffusion coefficients<br>
computed from vertical mixing parameterizations (GLS_MIXING,<br>
LMD_MIXING, MY25_MIXING). Sometimes, these parameterizations<br>
yield high mixing values and the threshold values are used as<br>
upper limiter when LIMIT_VDIFF is activated.</p>
<p>ad_AKT_fac   Adjoint-based algorithms vertical mixing, basic state, scale<br>
factor (nondimensional) for active (NAT) and inert (NPT)<br>
tracer variables. In some applications, smaller/larger<br>
values of vertical mixing are necessary for stability. It<br>
is only used when FORWARD_MIXING is activated.</p>
<hr>
<h2 id="vertical-mixing-coefficient-for-momentum">Vertical mixing coefficient for momentum.</h2>
<p>AKV_BAK      Background vertical mixing coefficient (m2/s) for momentum.</p>
<p>AKV_LIMIT    Upper threshold value to limit vertical viscosity coefficient<br>
computed from vertical mixing parameterizations (GLS_MIXING,<br>
LMD_MIXING, MY25_MIXING). Sometimes, these parameterizations<br>
yield a high mixing value and the threshold value is used as<br>
upper limiter when LIMIT_VVISC is activated.</p>
<p>ad_AKV_fac   Adjoint-based algorithms vertical mixing, basic state, scale<br>
factor (nondimensional) for momentum. In some applications,<br>
smaller/larger values of vertical mixing are necessary for<br>
stability. It is only used when FORWARD_MIXING is activated.</p>
<hr>
<h2 id="turbulent-closure-parameters">Turbulent closure parameters.</h2>
<p>AKK_BAK      Background vertical mixing coefficient (m2/s) for turbulent<br>
kinetic energy.</p>
<p>AKP_BAK      Background vertical mixing coefficient (m2/s) for turbulent<br>
generic statistical field, &quot;psi&quot;.</p>
<p>TKENU2       Lateral, harmonic, constant, mixing coefficient (m2/s) for<br>
turbulent closure variables.</p>
<p>TKENU4       Lateral, biharmonic, constant mixing coefficient (m4/s) for<br>
turbulent closure variables.</p>
<hr>
<h2 id="generic-length-scale-turbulence-closure-parameters">Generic length-scale turbulence closure parameters.</h2>
<p>GLS_P        Stability exponent (nondimensional).</p>
<p>GLS_M        Turbulent kinetic energy exponent (nondimensional).</p>
<p>GLS_N        Turbulent length scale exponent (nondimensional).</p>
<p>GLS_Kmin     Minimum value of specific turbulent kinetic energy</p>
<p>GLS_Pmin     Minimum Value of dissipation.</p>
<p>Closure independent constraint parameters (nondimensional):</p>
<p>GLS_CMU0     Stability coefficient.</p>
<p>GLS_C1       Shear production coefficient.</p>
<p>GLS_C2       Dissipation coefficient.</p>
<p>GLS_C3M      Buoyancy production coefficient (minus).</p>
<p>GLS_C3P      Buoyancy production coefficient (plus).</p>
<p>GLS_SIGK     Constant Schmidt number (nondimensional) for turbulent<br>
kinetic energy diffusivity.</p>
<p>GLS_SIGP     Constant Schmidt number (nondimensional) for turbulent<br>
generic statistical field, &quot;psi&quot;.</p>
<p>Suggested values for various parameterizations:</p>
<pre><code>          k-kl         k-epsilon    k-omega      gen

  GLS_P = 0.d0          3.0d0       -1.0d0        2.0d0
  GLS_M = 1.d0          1.5d0        0.5d0        1.0d0
  GLS_N = 1.d0         -1.0d0       -1.0d0       -0.67d0
</code></pre>
<p>GLS_Kmin = 5.0d-6        7.6d-6       7.6d-6       1.0d-8<br>
GLS_Pmin = 5.0d-6        1.0d-12      1.0d-12      1.0d-8</p>
<p>GLS_CMU0 = 0.5544d0      0.5477d0     0.5477d0     0.5544d0<br>
GLS_C1 = 0.9d0         1.44d0       0.555d0      1.00d0<br>
GLS_C2 = 0.52d0        1.92d0       0.833d0      1.22d0<br>
GLS_C3M = 2.5d0        -0.4d0       -0.6d0        0.1d0<br>
GLS_C3P = 1.0d0         1.0d0        1.0d0        1.0d0<br>
GLS_SIGK = 1.96d0        1.0d0        2.0d0        0.8d0<br>
GLS_SIGP = 1.96d0        1.30d0       2.0d0        1.07d0</p>
<hr>
<h2 id="constants-used-in-the-various-formulations-of-surface-turbulent-kineticenergy-flux-in-the-gls">Constants used in the various formulations of surface turbulent kinetic<br>
energy flux in the GLS.</h2>
<p>CHARNOK_ALPHA    Charnok surface roughness,<br>
Zos:   (charnok_alpha * u_star**2) / g</p>
<p>ZOS_HSIG_ALPHA   Roughness from wave amplitude,<br>
Zos:   zos_hsig_alpha * Hsig</p>
<p>SZ_ALPHA         Surface flux from wave dissipation,<br>
flux:  dt * sz_alpha * Wave_dissip</p>
<p>CRGBAN_CW        Surface flux due to Craig and Banner wave breaking,<br>
flux:  dt * crgban_cw * u_star**3</p>
<hr>
<h2 id="constants-used-in-the-computation-of-momentum-stress">Constants used in the computation of momentum stress.</h2>
<p>RDRG         Linear bottom drag coefficient (m/s).</p>
<p>RDRG2        Quadratic bottom drag coefficient.</p>
<p>Zob          Bottom roughness (m).</p>
<p>Zos          Surface roughness (m).</p>
<hr>
<h2 id="height-of-atmospheric-measurements-for-bulk-fluxes-parameterization">Height of atmospheric measurements for bulk fluxes parameterization.</h2>
<p>BLK_ZQ       Height (m) of surface air humidity measurement. Usually,<br>
recorded at 10 m.</p>
<p>BLK_ZT       Height (m) of surface air temperature measurement. Usually,<br>
recorded at 2 or 10 m.</p>
<p>BLK_ZW       Height (m) of surface winds measurement. Usually, recorded<br>
at 10 m.</p>
<hr>
<h2 id="wetting-and-drying-parameters">Wetting and drying parameters.</h2>
<p>DCRIT        Minimum depth (m) for wetting and drying.</p>
<hr>
<h2 id="jerlov-water-type">Jerlov Water type.</h2>
<p>WTYPE        Jerlov water type array index used to model the light absorption<br>
with a double exponential function (Paulson and Simpson,<br>
1977).  The classification ranges from clear open ocean<br>
waters (type I) to dark turbulent coastal waters (type 7).</p>
<pre><code>          Array     Jerlov
          Index   Water Type   Examples
          -----   ----------   --------

            1         I        Open Pacific
            2         IA       Eastern Mediterranean, Indian Ocean
            3         IB       Western Mediterranean, Open Atlantic
            4         II       Coastal waters, Azores
            5         III      Coastal waters, North Sea
            6         1        Skagerrak Strait
            7         3        Baltic
            8         5        Black Sea
            9         7        Dark coastal water
</code></pre>
<hr>
<h2 id="body-force-parameters-used-when-cpp-option-bodyforce-is-activated">Body-force parameters. Used when CPP option BODYFORCE is activated.</h2>
<p>LEVSFRC      Deepest level to apply surface momentum stress as a body-force.</p>
<p>LEVBFRC      Shallowest level to apply bottom momentum stress as a body-force.</p>
<hr>
<h2 id="vertical-s-coordinates-parameters">Vertical S-coordinates parameters.</h2>
<p>The parameters below must be consistent in all input fields associated with<br>
the vertical grid.  The same vertical grid transformation (depths) needs to<br>
be used when preparing initial conditions, boundary conditions, climatology,<br>
observations, and so on. Please check:</p>
<p>https://www.myroms.org/wiki/index.php/Vertical_S-coordinate</p>
<p>for details, rules and examples.</p>
<p>Vtransform   Vertical transformation equation:</p>
<pre><code>            (1) Original formulation (Shchepetkin and McWilliams, 2005),
                Vtransform=1 (In ROMS since 1999)

                  z(x,y,s,t)=Zo(x,y,s)+zeta(x,y,t)*[1+Zo(x,y,s)/h(x,y)]

                where

                  Zo(x,y,s)=hc*s+[h(x,y)-hc]*C(s)

            (2) Improved formulation (A. Shchepetkin, 2005),
                Vtransform=2

                  z(x,y,s,t)=zeta(x,y,t)*[zeta(x,y,t)+h(x,y)]*Zo(x,y,s)

                where

                  Zo(x,y,s)=[hc*s(k)+h(x,y)*C(k)]/[hc+h(x,y)]

                The true sigma-coordinate system is recovered as hc goes
                to INFINITY. This is useful when configuring applications
                with flat bathymetry and uniform level thickness.
                Practically, you can achieve this by setting:

                  THETA_S = 0.0d0
                  THETA_B = 0.0d0
                  TCLINE  = 1.0d+17       (a large number)
</code></pre>
<p>Vstretching  Vertical stretching function, C(s):</p>
<pre><code>            (1) Original function (Song and Haidvogel, 1994),
                Vstretching=1

                C(s)=(1-theta_b)*[SINH(s*theta_s)/SINH(theta_s)]+
                     theta_b*[-0.5+0.5*TANH(theta_s*(s+0.5))/
                                       TANH(0.5*theta_s)]

            (2) A. Shchepetkin (2005) function,
                Vstretching=2

                  C(s)=Cweight*Csur(s)+(1-Cweight)*Cbot(s)

                where

                  Csur(s)=[1-COSH(theta_s*s)]/[COSH(theta_s)-1]

                  Cbot(s)=-1+[1-SINH(theta_b*(s+1))]/SINH(theta_b)

                  Cweight=(s+1)**alpha*
                          (1+(alpha/beta)*(1-(s+1)**beta))

            (3) R. Geyer function for shallow sediment applications,
                Vstretching=3

                  C(s)=Cweight*Cbot(s)+(1-Cweight)*Csur(s)

                where

                  Csur(s)=-LOG(COSH(Hscale*ABS(s)** alpha))/
                           LOG(COSH(Hscale))

                  Cbot(s)= LOG(COSH(Hscale*(s+1)** beta))/
                           LOG(COSH(Hscale))-1

                  Cweight=0.5*(1-TANH(Hscale*(s+0.5))

            (4) A. Shchepetkin (2010) improved double stretching function,
                Vstretching=4

                  C(s)=[1-COSH(theta_s*s)]/[COSH(theta_s)-1]

                with bottom refinement

                  C(s)=[EXP(theta_b*C(s))-1]/[1-EXP(-theta_b)]

                The resulting double transformation is continuous with
                respect control parameters theta_s and theta_b with a
                meaningful range of:

                  0 &lt;  theta_s &lt;= 10.0
                  0 &lt;= theta_b &lt;=  4.0

             (5) Souza et al. (2015) quadratic Legendre polynomial function
                 that allows higher resolution near the surface,
                 Vstretching=5. It is similar to Vstretching=4, but the
                 fractional stretched vertical coordinate (s) is re-defined
                 as:

                   s(k)=- [(k*k - 2*k*N + k + N*N - N) / (N*N - N)]
                        - weight * [(k*k - k*N) / (1 - N)]

                 at vertical W-points, k=0,...,N and weight=0.01. To get
                 the equation at vertical RHO-points, replace k with k-0.5.

          Many other stretching functions (Vstretching&gt;5) are possible
          provided that:

            * C(s) is a dimensionless, nonlinear, monotonic function.
            * C(s) is a continuous differentiable function, or
              a differentiable piecewise function with smooth transition.
            * The stretching vertical coordinate ,s, is constrained
              between -1 &lt;= s &lt;= 0, with s=0 corresponding to the
              free-surface and s=-1 corresponding to the bathymetry.
            * Similarly, the stretching function, C(s), is constrained
              between -1 &lt;= C(s) &lt;= 0, with C(0)=0 corresponding to the
              free-surface and C(-1)=-1 corresponding to the bathymetry.

          These functions are coded in routine &quot;Utility/set_scoord.F&quot;.
</code></pre>
<p>Due to its functionality and properties, the default and recommended vertical<br>
coordinates transformation is:</p>
<pre><code>          Vtransform  = 2
          Vstretching = 4
</code></pre>
<p>THETA_S      S-coordinate surface control parameter. The range of optimal<br>
values depends on the vertical stretching function, C(s).</p>
<p>THETA_B      S-coordinate bottom  control parameter. The range of optimal<br>
values depends on the vertical stretching function, C(s).</p>
<p>TCLINE       Critical depth (hc) in meters (positive) controlling the<br>
stretching. It can be interpreted as the width of surface or<br>
bottom boundary layer in which higher vertical resolution<br>
(levels) is required during stretching.</p>
<hr>
<h2 id="mean-density-and-background-brunt-vaisala-frequency">Mean Density and background Brunt-Vaisala frequency.</h2>
<p>RHO0        Mean density (Kg/m3) used when the Boussinesq approximation<br>
is inferred.</p>
<p>BVF_BAK     Background Brunt-Vaisala frequency squared (1/s2). Typical<br>
values for the ocean range (as a function of depth) from<br>
1.0E-4 to 1.0E-6.</p>
<hr>
<h2 id="tide-genearting-forces-tgf-parameter">Tide Genearting Forces (TGF) parameter.</h2>
<p>Lnodal       Switch to account for the slow modulation of the equilibrium<br>
tides constituents due primarily to the 18.6-year lunar nodal<br>
cycle.</p>
<hr>
<h2 id="time-stamps">Time Stamps.</h2>
<p>DSTART       Time stamp assigned to model initialization (days).  Usually<br>
a Calendar linear coordinate, like modified Julian Day.  For<br>
Example:</p>
<pre><code>                     Julian Day    = 1      for  Nov 25, 00:00:00 4713 BCE
            modified Julian Day    = 1      for  May 24, 00:00:00 1968 GMT
            Days since Jan 1, 2000 = 988.5  for  Sep 15, 12:00:00 2002

            It is called truncated or modified Julian day because an
            offset of 2440000 needs to be added.
</code></pre>
<p>TIDE_START   Reference time origin for tidal forcing (days since application<br>
reference date, TIME_REF). It is defined as the time of phase<br>
zero when preparing the input forcing tidal boundary data. The<br>
tide reference time is important and often ignored parameter<br>
by the users. If TIDE_START=0.0, it implies that the date of<br>
zero phase is the same as the application date reference,<br>
TIME_REF.</p>
<pre><code>            To avoid any ambiguity with the tide generating forcing in the
            pressure gradient, it is preferable if the &quot;zero_phase_date&quot;
            variable is available in the input tidal forcing NetCDF file.
            It is a floating-point variable of the form YYYYMMDD.dddd with
            the following metadata:

   double zero_phase_date
         zero_phase_date:long_name = &quot;tidal reference date for zero phase&quot;
         zero_phase_date:units = &quot;days as %Y%m%d.%f&quot;
         zero_phase_date:C_format = &quot;%13.4f&quot;
         zero_phase_date:FORTRAN_format = &quot;(f13.4)&quot;

            Use &quot;forcing/add_tide_date.m&quot; from the ROMS Matlab repository
            to add the &quot;zero_phase_date&quot; variable to your existing tidal
            forcing NetCDF file. It is highly recommended to use this
            approach. If such a variable is found, the TIDE_START value
            will overwritten during execution.

            Notice that it is possible to have different reference values
            for &quot;zero_phase_date&quot; and ROMS clock defined as seconds from
            reference date TIME_REF. If TIME_REF is earlier than variable
            &quot;zero_phase_date&quot;, the frequencies (omega) to harmonic terms
            will be negative since they are computed as follows:

            tide_start = Rclock%tide_DateNumber(2) -
                         Rclock%DateNumber(2))
            omega = 2 * pi * (time - tide_start) / Tperiod
</code></pre>
<p>TIME_REF     Reference time (yyyymmdd.f) used to compute relative time:<br>
elapsed time interval since reference-time.  The &quot;units&quot;<br>
attribute takes the form &quot;time-unit since reference-time&quot;.<br>
This parameter also provides information about the calendar<br>
used:</p>
<pre><code>            If TIME_REF = -2, model time and DSTART are in modified Julian
            days units.  The &quot;units&quot; attribute is:

              'time-units since 1968-05-23 00:00:00 GMT'    (May 23, 1968)

            If TIME_REF = -1, model time and DSTART are in a calendar
            with 360 days in every year (30 days each month).  The &quot;units&quot;
            attribute is:

              'time-units since 0000-12-30 00:00:00'        (Dec 30, 0000)

            If TIME_REF = 0, model time and DSTART are in a common year
            calendar with 365.25 days.  The &quot;units&quot; attribute is:

              'time-units since 0001-01-01 00:00:00'        (Jan  1, 0001)

            If TIME_REF &gt; 0, model time and DSTART are the elapsed time
            units since specified reference time.  For example,
            TIME_REF=20020115.5 will yield the following attribute:

              'time-units since 2002-01-15 12:00:00'        (Jan 15, 2002)
</code></pre>
<hr>
<h2 id="nudgingrelaxation-time-scales-inverse-scales-will-be-computed-internally">Nudging/relaxation time scales, inverse scales will be computed internally.</h2>
<p>When passive/active open boundary conditions are activated, these nudging<br>
values correspond to the passive (outflow) nudging time scales.</p>
<p>TNUDG        Nudging time scale (days) for active tracer variables.<br>
(1:NAT+NPT,1:Ngrids) values are expected.</p>
<p>ZNUDG        Nudging time scale (days) for free-surface.</p>
<p>M2NUDG       Nudging time scale (days) for 2D momentum.</p>
<p>M3NUDG       Nudging time scale (days) for 3D momentum.</p>
<p>OBCFAC       Factor between passive (outflow) and active (inflow) open<br>
boundary conditions.  The nudging time scales for the<br>
active (inflow) conditions are obtained by multiplying<br>
the passive values by OBCFAC. If OBCFAC &gt; 1, nudging on<br>
inflow is stronger than on outflow (recommended).</p>
<hr>
<h2 id="linear-equation-of-state-parameters">Linear equation of State parameters.</h2>
<p>Ignoring pressure, the linear equation of state is:</p>
<pre><code>          rho(:,:,:) = R0 - R0 * TCOEF * (t(:,:,:,:,itemp) - T0)
                          + R0 * SCOEF * (t(:,:,:,:,isalt) - S0)

          Typical values:     R0 = 1027.0  kg/m3
                              T0 = 10.0    Celsius
                              S0 = 35.0    nondimensional
                           TCOEF = 1.7d-4  1/Celsius
                           SCOEF = 7.6d-4  1/nondimensional

          Notice that salinity has NO UNITS, it is nondimensional. Many
          people use PSU (Practical Salinity Unit).  However, salinity
          has always been defined as a conductivity ratio and does not
          have physical units. For details, check the following forum
          post:  www.myroms.org/forum/viewtopic.php?f=30&amp;t=294
</code></pre>
<p>R0           Background density value (Kg/m3) used in Linear Equation of<br>
State.</p>
<p>T0           Background potential temperature (Celsius) constant.</p>
<p>S0           Background salinity (nondimensional) constant.</p>
<p>TCOEF        Thermal expansion coefficient in Linear Equation of State.</p>
<p>SCOEF        Saline contraction coefficient in Linear Equation of State.</p>
<hr>
<h2 id="slipperiness-parameter">Slipperiness parameter.</h2>
<p>GAMMA2       Slipperiness variable, either 1.0 (free slip) or -1.0 (no slip).</p>
<hr>
<h2 id="point-sourcessink-sources-activation-switches">Point Sources/Sink sources activation switches.</h2>
<p>LuvSrc       Logical switches (T/F) to activate momentum horizontal transport<br>
points Sources/Sinks. Usually it is used to turn on/off river<br>
runoff transport (u or v variables) in an application,<br>
[1:Ngrids].</p>
<pre><code>            In nesting applications, turn on only the grids that require
            activation and processing of momentum point Sources/Sinks.
</code></pre>
<p>LwSrc        Logical switches (T/F) to activate mass points Sources/Sinks.<br>
Usually, it is used to turn on/off volume vertical influx (w)<br>
in an application.</p>
<pre><code>            In nesting applications, turn on only the grids that require
            activation and processing of mass influx point Sources/Sinks.
</code></pre>
<p>LtracerSrc   Logical switches (T/F) to activate tracer variables point<br>
Sources/Sinks. Only NAT active tracers (temperature, salinity)<br>
and NPT inert tracers are activated here:</p>
<pre><code>             LtracerSrc(itemp,ng)     for temperature (itemp=1)
             LtracerSrc(isalt,ng)     for salinity    (isalt=2)
             LtracerSrc(NAT+1,ng)     for inert tracer 1
             ...                      ...
             LtracerSrc(NAT+NPT,ng)   for inert tracer NPT

            Other biological and sediment tracers switches are activated
            in their respective input scripts.

            In nesting applications, turn on only the grids that require
            activation and processing of tracers point Sources/Sinks.

            Recall that switches are usually activated to add river runoff
            as a point source. At minimum, it is necessary to specify both
            temperature and salinity for all rivers.  The other tracers are
            optional.

            This logical switch REPLACES and ELIMINATES the need to have
            or read the variable &quot;river_flag(river)&quot; in the input rivers
            forcing NetCDF file:

             double river_flag(river)
                    river_flag:long_name = &quot;river runoff tracer flag&quot;
                    river_flag:option_0 = &quot;all tracers are off&quot;
                    river_flag:option_1 = &quot;only temperature&quot;
                    river_flag:option_2 = &quot;only salinity&quot;
                    river_flag:option_3 = &quot;both temperature and salinity&quot;
                    river_flag:units = &quot;nondimensional&quot;

            The above variable was too cumbersome and complicated when
            additional tracers are considered. However, this change is
            backward compatible.

            The LtracerSrc switch will be used to activate the reading of
            respective tracer variable from input river forcing NetCDF
            file. If you want to add other tracer variables (other than
            temperature and salinity) as a source for a particular
            river(s), you just need to specify such values on those
            river(s). Then, set the values to ZERO on the other river(s)
            that do NOT require such river forcing for that tracer.
            Recall that you need to specify the tracer values for all
            rivers, even if their values are zero.
</code></pre>
<hr>
<h2 id="logical-switches-to-process-climatology-fields-the-climatology-fields-areeither-read-from-a-netcdf-file-or-set-with-analytical-cpp-options">Logical switches to process climatology fields. The climatology fields are<br>
either read from a NetCDF file or set with analytical CPP options.</h2>
<p>LsshCLM      Logical switch (T/F) to process sea-surface height climatology.<br>
The CPP option ZCLIMATOLOGY is now obsolete and replaced with<br>
this switch to facilitate nesting applications. Currently,<br>
the sea-surface height climatology, CLIMA(ng)%ssh, is NOT<br>
used but it is kept for future use.</p>
<pre><code>            The nudging of SSH on the free-surface governing equation
            (vertically integrated continuity equation) is NOT allowed
            because it violates mass/volume conservation. Recall that
            the time rate of change of free-surface is computed from the
            divergence of &quot;ubar&quot; and &quot;vbar&quot;.  If such nudging term is
            required, it needs to be specified on the momentum equations
            for (u,v) and/or (ubar,vbar). If done on (u,v) only, its
            effects enter the 2D momentum equations via the residual
            vertically integrated forcing term.
</code></pre>
<p>Lm2CLM       Logical switch (T/F) to process 2D momentum (ubar, vbar)<br>
climatology. The CPP option M2CLIMATOLOGY is now obsolete<br>
and replaced with this switch to facilitate nesting<br>
applications. Currently, the CLIMA(ng)%ubarclm and<br>
CLIMA(ng)%vbarclm are used for sponges and nudging. If<br>
tidal forcing, the climatological values are adjusted to<br>
include tides.</p>
<p>Lm3CLM       Logical switch (T/F) to process 3D momentum climatology (u,v)<br>
The CPP option M3CLIMATOLOGY is now obsolete and replaced<br>
with this switch to facilitate nesting applications.<br>
Currently, the CLIMA(ng)%uclm and CLIMA(ng)%vclm are used<br>
for sponges and nudging.</p>
<p>LtracerCLM   Logical switches (T/F) to process active and inert tracer<br>
variables climatology.  The CPP option TCLIMATOLOGY is now<br>
obsolete and replaced with these switches to facilitate<br>
nesting applications. Currently, the CLIMA(ng)%tclm is<br>
used for horizontal mixing, sponges, and nudging.</p>
<pre><code>            Only NAT active tracers (temperature, salinity) and NPT inert
            tracers need to be specified here:

             LtracerCLM(itemp,ng)     for temperature (itemp=1)
             LtracerCLM(isalt,ng)     for salinity    (isalt=2)
             LtracerCLM(NAT+1,ng)     for inert tracer 1
             ...                      ...
             LtracerCLM(NAT+NPT,ng)   for inert tracer NPT

            Other biological and sediment tracers switches are specified
            in their respective input scripts.

            These switches also controls which climatology tracer fields
            (specially passive tracers) needs to be processed.  So we
            may reduce the memory allocation for the CLIMA(ng)%tclm array.
</code></pre>
<hr>
<h2 id="logical-switches-for-nudging-to-climatology-fields">Logical switches for nudging to climatology fields.</h2>
<p>LnudgeM2CLM   Logical switch (T/F) to activate the nudging of 2D momentum<br>
climatology.  The CPP option M2CLM_NUDGING is now obsolete<br>
and replaced with this switch to facilitate nesting<br>
applications.  Users also need to TURN ON the logical<br>
switch &quot;Lm2CLM&quot;, described above, to process the required<br>
2D momentum climatology data.  This data can be set with<br>
analytical functions (ANA_M2CLIMA) or read from input<br>
climatology NetCDF file(s).</p>
<pre><code>             The nudging coefficients CLIMA(ng)%M2nudgcof can be set
             with analytical functions in &quot;ana_nudgcoef.h&quot; using CPP
             option ANA_NUDGCOEF.  Otherwise, it will be read from
             NetCDF file NUDNAME.
</code></pre>
<p>LnudgeM3CLM   Logical switch (T/F) to activate the nudging of 3D momentum<br>
climatology.  The CPP option M3CLM_NUDGING is now obsolete<br>
and replaced with this switch to facilitate nesting<br>
applications.</p>
<pre><code>             Users also need to TURN ON the logical switch &quot;Lm3CLM&quot;,
             described above, to process the required 3D momentum
             climatology data.  This data can be set with analytical
             functions (ANA_M3CLIMA) or read from input climatology
             NetCDF file(s).

             The nudging coefficients CLIMA(ng)%M3nudgcof can be set
             with analytical functions in &quot;ana_nudgcoef.h&quot;  using CPP
             option ANA_NUDGCOEF.  Otherwise, it will be read from
             NetCDF file NUDNAME.
</code></pre>
<p>LnudgeTCLM    Logical switches (T/F) to activate the nudging of active and<br>
inert tracer variables climatology. These switches also<br>
control which tracer variables to nudge.  The CPP option<br>
TCLM_NUDGING is now obsolete and replaced with these<br>
switches to facilitate nesting applications.</p>
<pre><code>             Only NAT active tracers (temperature, salinity) and NPT
             inert tracers need to be specified here:

               LnudgeTCLM(itemp,ng)     for temperature (itemp=1)
               LnudgeTCLM(isalt,ng)     for salinity    (isalt=2)
               LnudgeTCLM(NAT+1,ng)     for inert tracer 1
               ...                      ...
               LnudgeTCLM(NAT+NPT,ng)   for inert tracer NPT

             Other biological and sediment tracers switches are specified
             in their respective input scripts.

             User also needs to TURN ON the respective logical switches
             &quot;LtracerCLM&quot;, described above, to process the required 3D
             tracer climatology data. This data can be set with analytical
             functions (ANA_TCLIMA) or read from input climatology
             NetCDF file(s).

             The nudging coefficients CLIMA(ng)%Tnudgcof can be set
             with analytical functions in &quot;ana_nudgcoef.h&quot;  using CPP
             option ANA_NUDGCOEF.  Otherwise, it will be read from
             NetCDF file NUDNAME.
</code></pre>
<hr>
<h2 id="adjoint-sensitivity-parameters">Adjoint sensitivity parameters.</h2>
<p>DstrS        Starting day for adjoint sensitivity forcing.</p>
<p>DendS        Ending   day for adjoint sensitivity forcing.</p>
<pre><code>            The adjoint forcing is applied at every time step according
            to desired state functional stored in the adjoint sensitivity
            NetCDF file. DstrS must be less than or equal to DendS. If
            both values are zero, their values are reset internally to
            the full range of the adjoint integration.
</code></pre>
<p>KstrS       Starting vertical level of the 3D adjoint state variables whose<br>
sensitivity is required.</p>
<p>KendS       Ending   vertical level of the 3D adjoint state variables whose<br>
sensitivity is required.</p>
<p>Lstate      Logical switches (TRUE/FALSE) to specify the adjoint state<br>
variables whose sensitivity is required.</p>
<pre><code>            Lstate(isFsur):   Free-surface
            Lstate(isUbar):   2D U-momentum
            Lstate(isVbar):   2D V-momentum
            Lstate(isUvel):   3D U-momentum
            Lstate(isVvel):   3D V-momentum
            Lstate(isWvel):   3D W-momentum
            Lstate(isTvar):   Traces (NT values expected)
</code></pre>
<hr>
<h2 id="forcing-singular-vectors-or-stochastic-optimals-parameters">Forcing Singular Vectors or Stochastic Optimals parameters.</h2>
<p>Fstate       Logical switches (TRUE/FALSE) to specify state variables for<br>
which Forcing Singular Vectors or Stochastic Optimals is<br>
required.</p>
<pre><code>            Fstate(isFsur):   Free-surface
            Fstate(isUbar):   2D U-momentum
            Fstate(isVbar):   2D V-momentum
            Fstate(isUvel):   3D U-momentum
            Fstate(isVvel):   3D V-momentum
            Fstate(isTvar):   Traces (NT values expected)

            Fstate(isUstr):   surface U-stress
            Fstate(isVstr):   surface V-stress
            Fstate(isTsur):   surface tracers flux (NT values expected)
</code></pre>
<p>SO_decay     Stochastic Optimals time decorrelation scale (days) assumed<br>
for red noise processes.</p>
<p>SO_sdev      Stochastic Optimals surface forcing standard deviation for<br>
dimensionalization.</p>
<pre><code>            SO_sdev(isFsur):  Free-surface
            SO_sdev(isUbar):  2D U-momentum
            SO_sdev(isVbar):  2D V-momentum
            SO_sdev(isUvel):  3D U-momentum
            SO_sdev(isVvel):  3D V-momentum
            SO_sdev(isTvar):  Traces (NT values expected)

            SO_sdev(isUstr):  surface U-stress
            SO_sdev(isVstr):  surface V-stress
            SO_sdev(isTsur):  surface tracer flux (NT values expected)
</code></pre>
<hr>
<h2 id="logical-switches-tf-to-activate-writing-of-instantaneous-fields-intohistory-file">Logical switches (T/F) to activate writing of instantaneous fields into<br>
HISTORY file.</h2>
<p>Hout(idUvel)   Write out 3D U-velocity component.<br>
Hout(idVvel)   Write out 3D V-velocity component.<br>
Hout(idu3dE)   Write out 3D Eastward  velocity component at RHO-points.<br>
Hout(idv3dN)   Write out 3D Northward velocity component at RHO-points.<br>
Hout(idWvel)   Write out 3D W-velocity component.<br>
Hout(idOvel)   Write out 3D omega vertical velocity.<br>
Hout(idUbar)   Write out 2D U-velocity component.<br>
Hout(idVbar)   Write out 2D V-velocity component.<br>
Hout(idu2dE)   Write out 2D Eastward  velocity component at RHO-points.<br>
Hout(idv2dN)   Write out 2D Northward velocity component at RHO-points.<br>
Hout(idFsur)   Write out free-surface.<br>
Hout(idBath)   Write out time-dependent bathymetry.</p>
<p>Hout(idTvar)   Write out active (NAT) tracers: temperature and salinity.</p>
<p>Hout(idpthR)   Write out time-varying depths of RHO-points.<br>
Hout(idpthU)   Write out time-varying depths of U-points.<br>
Hout(idpthV)   Write out time-varying depths of V-points.<br>
Hout(idpthW)   Write out time-varying depths of W-points.</p>
<p>Hout(idUsms)   Write out surface U-momentum stress.<br>
Hout(idVsms)   Write out surface V-momentum stress.<br>
Hout(idUbms)   Write out bottom  U-momentum stress.<br>
Hout(idVbms)   Write out bottom  V-momentum stress.</p>
<p>Hout(idUbrs)   Write out current-induced, U-momentum stress.<br>
Hout(idVbrs)   Write out current-induced, V-momentum stress.<br>
Hout(idUbws)   Write out wind-induced, bottom U-wave stress.<br>
Hout(idVbws)   Write out wind-induced, bottom V-wave stress.<br>
Hout(idUbcs)   Write out bottom maximum wave and current U-stress.<br>
Hout(idVbcs)   Write out bottom maximum wave and current V-stress.</p>
<p>Hout(idUbot)   Write out wind-induced, bed wave orbital U-velocity.<br>
Hout(idVbot)   Write out wind-induced, bed wave orbital V-velocity.<br>
Hout(idUbur)   Write out bottom U-velocity above bed.<br>
Hout(idVbvr)   Write out bottom V-velocity above bed.</p>
<p>Hout(idW2xx)   Write out 2D radiation stress, Sxx component.<br>
Hout(idW2xy)   Write out 2D radiation stress, Sxy component.<br>
Hout(idW2yy)   Write out 2D radiation stress, Syy component.<br>
Hout(idU2rs)   Write out 2D U-radiation stress.<br>
Hout(idV2rs)   Write out 2D V-radiation stress.<br>
Hout(idU2Sd)   Write out 2D U-Stokes velocity.<br>
Hout(idV2Sd)   Write out 2D V-Stokes velocity.</p>
<p>Hout(idW3xx)   Write out 3D radiation stress, Sxx component.<br>
Hout(idW3xy)   Write out 3D radiation stress, Sxy component.<br>
Hout(idW3yy)   Write out 3D radiation stress, Syy component.<br>
Hout(idW3zx)   Write out 3D radiation stress, Szx component.<br>
Hout(idW3zy)   Write out 3D radiation stress, Szy component.<br>
Hout(idU3rs)   Write out 3D U-radiation stress.<br>
Hout(idV3rs)   Write out 3D V-radiation stress.<br>
Hout(idU3Sd)   Write out 3D U-Stokes velocity.<br>
Hout(idV3Sd)   Write out 3D V-Stokes velocity.</p>
<p>Hout(idWamp)   Write out wave height.<br>
Hout(idWlen)   Write out wave length.<br>
Hout(idWdir)   Write out wave direction.<br>
Hout(idWptp)   Write out wave surface period.<br>
Hout(idWpbt)   Write out wave bottom period.<br>
Hout(idWorb)   Write out wave bottom orbital velocity.<br>
Hout(idWdis)   Write out wave dissipation.</p>
<p>Hout(idPair)   Write out surface air pressure.<br>
Hout(idTair)   Write out surface air temperature.<br>
Hout(idUair)   Write out surface U-wind component.<br>
Hout(idVair)   Write out surface V-wind component.</p>
<p>Hout(idTsur)   Write out surface net heat and salt flux<br>
Hout(idLhea)   Write out latent heat flux.<br>
Hout(idShea)   Write out sensible heat flux.<br>
Hout(idLrad)   Write out long-wave radiation flux.<br>
Hout(idSrad)   Write out short-wave radiation flux.<br>
Hout(idEmPf)   Write out E-P flux.<br>
Hout(idevap)   Write out evaporation rate.<br>
Hout(idrain)   Write out precipitation rate.</p>
<p>Hout(idDano)   Write out density anomaly.<br>
Hout(idVvis)   Write out vertical viscosity coefficient.<br>
Hout(idTdif)   Write out vertical diffusion coefficient of temperature.<br>
Hout(idSdif)   Write out vertical diffusion coefficient of salinity.<br>
Hout(idHsbl)   Write out depth of oceanic surface boundary layer.<br>
Hout(idHbbl)   Write out depth of oceanic bottom boundary layer.<br>
Hout(idMtke)   Write out turbulent kinetic energy.<br>
Hout(idMtls)   Write out turbulent kinetic energy times length scale.</p>
<p>Hout(inert)    Write out extra inert passive tracers.</p>
<hr>
<h2 id="logical-switches-tf-to-activate-writing-of-instantaneous-fields-intoquicksave-file">Logical switches (T/F) to activate writing of instantaneous fields into<br>
QUICKSAVE file.</h2>
<p>Qout(idUvel)   Write out 3D U-velocity component.<br>
Qout(idVvel)   Write out 3D V-velocity component.<br>
Qout(idu3dE)   Write out 3D Eastward  velocity component at RHO-points.<br>
Qout(idv3dN)   Write out 3D Northward velocity component at RHO-points.<br>
Qout(idWvel)   Write out 3D W-velocity component.<br>
Qout(idOvel)   Write out 3D omega vertical velocity.<br>
Qout(idUbar)   Write out 2D U-velocity component.<br>
Qout(idVbar)   Write out 2D V-velocity component.<br>
Qout(idu2dE)   Write out 2D Eastward  velocity component at RHO-points.<br>
Qout(idv2dN)   Write out 2D Northward velocity component at RHO-points.<br>
Qout(idFsur)   Write out free-surface.<br>
Qout(idBath)   Write out time-dependent bathymetry.</p>
<p>Qout(idTvar)   Write out active (NAT) tracers: temperature and salinity.</p>
<p>Qout(idUsur)   Write out surface U-velocity component.<br>
Qout(idVsur)   Write out surface V-velocity component.<br>
Qout(idUsuE)   Write out surface Eastward  velocity component at RHO-points.<br>
Qout(idVsuN)   Write out surface Northward velocity component at RHO-points.</p>
<p>Qout(idsurT)   Write out surface temperature and salinity</p>
<p>Qout(idpthR)   Write out time-varying depths of RHO-points.<br>
Qout(idpthU)   Write out time-varying depths of U-points.<br>
Qout(idpthV)   Write out time-varying depths of V-points.<br>
Qout(idpthW)   Write out time-varying depths of W-points.</p>
<p>Qout(idUsms)   Write out surface U-momentum stress.<br>
Qout(idVsms)   Write out surface V-momentum stress.<br>
Qout(idUbms)   Write out bottom  U-momentum stress.<br>
Qout(idVbms)   Write out bottom  V-momentum stress.</p>
<p>Qout(idUbrs)   Write out current-induced, U-momentum stress.<br>
Qout(idVbrs)   Write out current-induced, V-momentum stress.<br>
Qout(idUbws)   Write out wind-induced, bottom U-wave stress.<br>
Qout(idVbws)   Write out wind-induced, bottom V-wave stress.<br>
Qout(idUbcs)   Write out bottom maximum wave and current U-stress.<br>
Qout(idVbcs)   Write out bottom maximum wave and current V-stress.</p>
<p>Qout(idUbot)   Write out wind-induced, bed wave orbital U-velocity.<br>
Qout(idVbot)   Write out wind-induced, bed wave orbital V-velocity.<br>
Qout(idUbur)   Write out bottom U-velocity above bed.<br>
Qout(idVbvr)   Write out bottom V-velocity above bed.</p>
<p>Qout(idW2xx)   Write out 2D radiation stress, Sxx component.<br>
Qout(idW2xy)   Write out 2D radiation stress, Sxy component.<br>
Qout(idW2yy)   Write out 2D radiation stress, Syy component.<br>
Qout(idU2rs)   Write out 2D U-radiation stress.<br>
Qout(idV2rs)   Write out 2D V-radiation stress.<br>
Qout(idU2Sd)   Write out 2D U-Stokes velocity.<br>
Qout(idV2Sd)   Write out 2D V-Stokes velocity.</p>
<p>Qout(idW3xx)   Write out 3D radiation stress, Sxx component.<br>
Qout(idW3xy)   Write out 3D radiation stress, Sxy component.<br>
Qout(idW3yy)   Write out 3D radiation stress, Syy component.<br>
Qout(idW3zx)   Write out 3D radiation stress, Szx component.<br>
Qout(idW3zy)   Write out 3D radiation stress, Szy component.<br>
Qout(idU3rs)   Write out 3D U-radiation stress.<br>
Qout(idV3rs)   Write out 3D V-radiation stress.<br>
Qout(idU3Sd)   Write out 3D U-Stokes velocity.<br>
Qout(idV3Sd)   Write out 3D V-Stokes velocity.</p>
<p>Qout(idWamp)   Write out wave height.<br>
Qout(idWlen)   Write out wave length.<br>
Qout(idWdir)   Write out wave direction.<br>
Qout(idWptp)   Write out wave surface period.<br>
Qout(idWpbt)   Write out wave bottom period.<br>
Qout(idWorb)   Write out wave bottom orbital velocity.<br>
Qout(idWdis)   Write out wave dissipation.</p>
<p>Qout(idPair)   Write out surface air pressure.<br>
Qout(idTair)   Write out surface air temperature.<br>
Qout(idUair)   Write out surface U-wind component.<br>
Qout(idVair)   Write out surface V-wind component.</p>
<p>Qout(idTsur)   Write out surface net heat and salt flux<br>
Qout(idLhea)   Write out latent heat flux.<br>
Qout(idShea)   Write out sensible heat flux.<br>
Qout(idLrad)   Write out long-wave radiation flux.<br>
Qout(idSrad)   Write out short-wave radiation flux.<br>
Qout(idEmPf)   Write out E-P flux.<br>
Qout(idevap)   Write out evaporation rate.<br>
Qout(idrain)   Write out precipitation rate.</p>
<p>Qout(idDano)   Write out density anomaly.<br>
Qout(idVvis)   Write out vertical viscosity coefficient.<br>
Qout(idTdif)   Write out vertical diffusion coefficient of temperature.<br>
Qout(idSdif)   Write out vertical diffusion coefficient of salinity.<br>
Qout(idHsbl)   Write out depth of oceanic surface boundary layer.<br>
Qout(idHbbl)   Write out depth of oceanic bottom boundary layer.<br>
Qout(idMtke)   Write out turbulent kinetic energy.<br>
Qout(idMtls)   Write out turbulent kinetic energy times length scale.</p>
<p>Qout(inert)    Write out inert passive tracers.<br>
Qout(Snert)    Write out surface inert passive tracers.</p>
<hr>
<h2 id="logical-switches-tf-to-activate-writing-of-time-averaged-fields-intoaverage-file">Logical switches (T/F) to activate writing of time-averaged fields into<br>
AVERAGE file.</h2>
<p>Aout(idUvel)   Write out 3D U-velocity component.<br>
Aout(idVvel)   Write out 3D V-velocity component.<br>
Aout(idu3dE)   Write out 3D Eastward  velocity component at RHO-points.<br>
Aout(idv3dN)   Write out 3D Northward velocity component at RHO-points.<br>
Aout(idWvel)   Write out 3D W-velocity component.<br>
Aout(idOvel)   Write out 3D omega vertical velocity.<br>
Aout(idUbar)   Write out 2D U-velocity component.<br>
Aout(idVbar)   Write out 2D V-velocity component.<br>
Aout(idu2dE)   Write out 2D Eastward  velocity component at RHO-points.<br>
Aout(idv2dN)   Write out 2D Northward velocity component at RHO-points.<br>
Aout(idFsur)   Write out free-surface.</p>
<p>Aout(idTvar)   Write out active (NAT) tracers: temperature and salinity.</p>
<p>Aout(idUsms)   Write out surface U-momentum stress.<br>
Aout(idVsms)   Write out surface V-momentum stress.<br>
Aout(idUbms)   Write out bottom  U-momentum stress.<br>
Aout(idVbms)   Write out bottom  V-momentum stress.</p>
<p>Aout(idW2xx)   Write out 2D radiation stress, Sxx component.<br>
Aout(idW2xy)   Write out 2D radiation stress, Sxy component.<br>
Aout(idW2yy)   Write out 2D radiation stress, Syy component.<br>
Aout(idU2rs)   Write out 2D U-radiation stress.<br>
Aout(idV2rs)   Write out 2D V-radiation stress.<br>
Aout(idU2Sd)   Write out 2D U-Stokes velocity.<br>
Aout(idV2Sd)   Write out 2D V-Stokes velocity.</p>
<p>Aout(idW3xx)   Write out 3D radiation stress, Sxx component.<br>
Aout(idW3xy)   Write out 3D radiation stress, Sxy component.<br>
Aout(idW3yy)   Write out 3D radiation stress, Syy component.<br>
Aout(idW3zx)   Write out 3D radiation stress, Szx component.<br>
Aout(idW3zy)   Write out 3D radiation stress, Szy component.<br>
Aout(idU3rs)   Write out 3D U-radiation stress.<br>
Aout(idV3rs)   Write out 3D V-radiation stress.<br>
Aout(idU3Sd)   Write out 3D U-Stokes velocity.<br>
Aout(idV3Sd)   Write out 3D V-Stokes velocity.</p>
<p>Aout(idPair)   Write out surface air pressure.<br>
Aout(idTair)   Write out surface air temperature.<br>
Aout(idUair)   Write out surface U-wind component.<br>
Aout(idVair)   Write out surface V-wind component.</p>
<p>Aout(idTsur)   Write out surface net heat and salt flux<br>
Aout(idLhea)   Write out latent heat flux.<br>
Aout(idShea)   Write out sensible heat flux.<br>
Aout(idLrad)   Write out long-wave radiation flux.<br>
Aout(idSrad)   Write out short-wave radiation flux.<br>
Aout(idevap)   Write out evaporation rate.<br>
Aout(idrain)   Write out precipitation rate.</p>
<p>Aout(idDano)   Write out density anomaly.<br>
Aout(idVvis)   Write out vertical viscosity coefficient.<br>
Aout(idTdif)   Write out vertical diffusion coefficient of temperature.<br>
Aout(idSdif)   Write out vertical diffusion coefficient of salinity.<br>
Aout(idHsbl)   Write out depth of oceanic surface boundary layer.<br>
Aout(idHbbl)   Write out depth of oceanic bottom boundary layer.</p>
<p>Aout(id2dRV)   Write out 2D relative vorticity (vertically integrated).<br>
Aout(id3dRV)   Write out 3D relative vorticity.<br>
Aout(id2dPV)   Write out 2D potential vorticity (shallow water).<br>
Aout(id3dPV)   Write out 3D potential vorticity.</p>
<p>Aout(idu3dD)   Write out detided 3D U-velocity.<br>
Aout(idv3dD)   Write out detided 3D V-velocity.<br>
Aout(idu2dD)   Write out detided 2D U-velocity.<br>
Aout(idv2dD)   Write out detided 2D V-velocity.<br>
Aout(idFsuD)   Write out detided free-surface</p>
<p>Aout(idTrcD)   Write out detided temperature and salinity.</p>
<p>Aout(idHUav)   Write out u-volume flux, Huon.<br>
Aout(idHVav)   Write out v-volume flux, Hvom.<br>
Aout(idUUav)   Write out quadratic &lt;u<em>u&gt; term.<br>
Aout(idUVav)   Write out quadratic &lt;u</em>v&gt; term.<br>
Aout(idVVav)   Write out quadratic &lt;v<em>v&gt; term.<br>
Aout(idU2av)   Write out quadratic &lt;ubar</em>ubar&gt; term.<br>
Aout(idV2av)   Write out quadratic &lt;vbar<em>vbar&gt; term.<br>
Aout(idZZav)   Write out quadratic &lt;zeta</em>zeta&gt; term.</p>
<p>Aout(idTTav)   Write out quadratic &lt;t<em>t&gt; active and inert tracers terms.<br>
Aout(idUTav)   Write out quadratic &lt;u</em>t&gt; active and inert tracers terms.<br>
Aout(idVTav)   Write out quadratic &lt;v<em>t&gt; active and inert tracers terms.<br>
Aout(iHUTav)   Write out active and inert tracer u-volume flux, &lt;Huon</em>t&gt;.<br>
Aout(iHVTav)   Write out active and inert tracer v-volume flux, &lt;Hvom*t&gt;.</p>
<p>Aout(inert)    Write out extra inert passive tracers.</p>
<hr>
<h2 id="logical-switches-tf-to-activate-writing-of-time-averaged-fields-intodiagnostic-file">Logical switches (T/F) to activate writing of time-averaged fields into<br>
DIAGNOSTIC file.</h2>
<p>Time-averaged, 2D momentum (ubar,vbar) diagnostic terms:<br>
(if DIAGNOSTICS_UV)</p>
<p>Dout(M2rate)   Write out acceleration.<br>
Dout(M2pgrd)   Write out pressure gradient.<br>
Dout(M2fcor)   Write out Coriolis force, if UV_COR.<br>
Dout(M2hadv)   Write out horizontal total advection, if UV_ADV.<br>
Dout(M2xadv)   Write out horizontal  XI-advection, if UV_ADV.<br>
Dout(M2yadv)   Write out horizontal ETA-advection, if UV_ADV.<br>
Dout(M2hrad)   Write out horizontal total radiation stress, NEARSHORE_MELLOR.<br>
Dout(M2hvis)   Write out horizontal total viscosity, if UV_VIS2 or UV_VIS4.<br>
Dout(M2xvis)   Write out horizontal  XI-viscosity, if UV_VIS2 or UV_VIS4.<br>
Dout(M2yvis)   Write out horizontal ETA-viscosity, if UV_VIS2 or UV_VIS4.<br>
Dout(M2sstr)   Write out surface stress.<br>
Dout(M2bstr)   Write out bottom stress</p>
<p>Time-averaged, 3D momentum (u,v) diagnostic terms:<br>
(if SOLVE3D and DIAGNOSTICS_UV)</p>
<p>Dout(M3rate)   Write out acceleration.<br>
Dout(M3pgrd)   Write out pressure gradient.<br>
Dout(M3fcor)   Write out Coriolis force, if UV_COR.<br>
Dout(M3hadv)   Write out horizontal total advection, if UV_ADV.<br>
Dout(M3xadv)   Write out horizontal  XI-advection, if UV_ADV.<br>
Dout(M3yadv)   Write out horizontal ETA-advection, if UV_ADV.<br>
Dout(M3hrad)   Write out horizontal total radiation stress, NEARSHORE_MELLOR.<br>
Dout(M3vrad)   Write out vertical radiation stress, if NEARSHORE_MELLOR.<br>
Dout(M3hvis)   Write out horizontal total viscosity, if UV_VIS2 or UV_VIS4.<br>
Dout(M3xvis)   Write out horizontal  XI-viscosity, if UV_VIS2 or UV_VIS4.<br>
Dout(M3yvis)   Write out horizontal ETA-viscosity, if UV_VIS2 or UV_VIS4.<br>
Dout(M3yvis)   Write out horizontal ETA-viscosity, if UV_VIS2 or UV_VIS4.<br>
Dout(M3vvis)   Write out vertical viscosity.</p>
<p>Time-averaged, active (temperature and salinity) and passive (inert) tracer<br>
diagnostic terms, [1:NAT+NPT,Ngrids] values expected:<br>
(if SOLVE3D and DIAGNOSTICS_TS)</p>
<p>Dout(iTrate)   Write out time rate of change.<br>
Dout(iThadv)   Write out horizontal total advection.<br>
Dout(iTxadv)   Write out horizontal  XI-advection.<br>
Dout(iTyadv)   Write out horizontal ETA-advection.<br>
Dout(iTvadv)   Write out vertical advection.<br>
Dout(iThdif)   Write out horizontal total diffusion, if TS_DIF2 or TS_DIF4.<br>
Dout(iTxdif)   Write out horizonta1  XI-diffusion, if TS_DIF2 or TS_DIF4.<br>
Dout(iTydif)   Write out horizontal ETA-diffusion, if TS_DIF2 or TS_DIF4.<br>
Dout(iTsdif)   Write out horizontal   S-diffusion, if TS_DIF2 or TS_DIF4 and<br>
rotated tensor (MIX_GEO_TS or MIX_ISO_TS).<br>
Dout(iTvdif)   Write out vertical diffusion.</p>
<hr>
<h2 id="generic-user-parameters">Generic User parameters.</h2>
<p>NUSER        Number of User parameters to consider (integer).</p>
<p>USER         Vector containing user parameters (real array). This array<br>
is used with the SANITY_CHECK to test the correctness of<br>
the tangent linear adjoint models.  It contains information<br>
of the model variable and grid point to perturb:</p>
<pre><code>            INT(user(1)):  tangent state variable to perturb
            INT(user(2)):  adjoint state variable to perturb
                           [isFsur=1] free-surface
                           [isUbar=2] 2D U-momentum
                           [isVbar=3] 2D V-momentum
                           [isUvel=4] 3D U-momentum
                           [isVvel=5] 3D V-momentum
                           [isTvar=6] First tracer (temperature)
                           [   ...  ]
                           [isTvar=?] Last tracer

            INT(user(3)):  I-index of tangent variable to perturb
            INT(user(4)):  I-index of adjoint variable to perturb
            INT(user(5)):  J-index of tangent variable to perturb
            INT(user(6)):  J-index of adjoint variable to perturb
            INT(user(7)):  K-index of tangent variable to perturb, if 3D
            INT(user(8)):  K-index of adjoint variable to perturb, if 3D

            Set tangent and adjoint parameters to the same values
            if perturbing and reporting the same variable.
</code></pre>
<hr>
<h2 id="io-options-and-parameters-a-more-complete-description-of-the-availableoptions-can-be-found-in-wikiroms-httpsmyromsorgwikiio">I/O options and parameters. A more complete description of the available<br>
options can be found in WikiROMS (https://myroms.org/wiki/IO).</h2>
<p>The ROMS input and output NetCDF files can be processed using the standard<br>
NetCDF library developed by UNIDATA, the Parallel-IO (PIO) library developed<br>
at NCAR, or the SCORPIO library available in E3SM (Sreepathi et al., 2013;<br>
doi:10.1109/HiPC.2013.6799128). The SCORPIO library was forked from the PIO<br>
library several years ago, and they have evolved separately. In addition to<br>
the standard NetCDF library, ROMS can be compiled with either the PIO or<br>
SCORPIO libraries. Check  www.myroms.org/wiki/External_Libraries  for more<br>
information on how to obtain and install these libraries. The user has the<br>
choice to select which library is used to process input and output NetCDF<br>
files. For parallel I/O, we recommend using the PIO library because it is<br>
more efficient than the SCORPIO library in our benchmark tests.</p>
<p>The Parallel I/O using the PIO or SCORPIO libraries is restricted to<br>
distributed-memory applications because it uses MPI-IO implementations<br>
like ROMIO.</p>
<ul>
<li>
<p>ROMS Input and Output NetCDF library to use flag: [1 or 2]</p>
<p>[1] Standard NetCDF3 or NetCDF4 library (Unidata)<br>
[2] Serial/Parallel I/O using Paralle-IO (PIO) library (MPI applications)</p>
</li>
</ul>
<p>INP_LIB      Reading library flag for input NetCDF files</p>
<p>OUT_LIB      Creation/writing library flag for output NetCDF files</p>
<ul>
<li>
<p>PIO method flag for reading/writing NetCDF files: [0,1,2,3,4]</p>
<p>[0] parallel read and write of PnetCDF files (CDF-5 type)<br>
[1] parallel read and write of PnetCDF files (NetCDF3 64-bit offset type)<br>
[2] serial   read and write of NetCDF3 files (NetCDF3 64-bit offset type)<br>
[3] parallel read and serial write of NetCDF4/HDF5 files (NetCDF4 type)<br>
[4] parallel read and write of NETCDF4/HDF5 files (NetCDF4 type)</p>
</li>
</ul>
<p>PIO_METHOD   PIO library file type for reading or writing. Depending on<br>
the build of the PIO library, not all the I/O types are<br>
available. If NetCDF library does not support parallel I/O,<br>
PIO_METHOD=3,4 are not available. Notice that we can create<br>
CDF-5 type PnetCDF files (PIO_METHOD=0), but it is not<br>
recommended because portability and post-processing<br>
constraints. Currently, NetCDF4/HDF5 data compression is<br>
possible with PIO_METHOD=3 during serial write.</p>
<ul>
<li>PIO library processes set-up:</li>
</ul>
<p>PIO_IOTASKS  Number of MPI processors used for I/O. If I/O decomposition is<br>
identical to the computational decomposition, PIO_IOTASK is<br>
equal to NtileI*NtileJ.  Typically, it is advantageous and<br>
highly recommended to define the I/O decomposition in smaller<br>
number of processes for efficiency and to avoid MPI<br>
communication bottlenecks.</p>
<p>PIO_STRIDE   Stride step in the MPI-rank between I/O tasks.</p>
<p>PIO_BASE     Offset for the first I/O task (usually, PIO_BASE=1).</p>
<p>PIO_AGGREG   Number of MPI-aggregators to use in intra-communication mode to<br>
improve MPI collective I/O performance.</p>
<pre><code>          In intra-communications mode, all processors in OCN_COMM_WORLD
          are involved in computations. A subset or all processors does
          I/O (and also computations). The PIO_IOTASKS and PIO_STRIDE
          parameters specify the total number of I/O tasks and the stride
          between them with respect to the ROMS MPI-communicator object,
          OCN_COMM_WORLD. The optional PIO_BASE parameter is used to shift
          the first I/O task away from the first computational task. This
          is often desirable because the application's first computational
          task usually has higher memory requirements than other processes.
          If the MPI-processes are spread over several hardware nodes, it
          is highly recommended to use a value for PIO_STRIDE that scatters
          the I/O processes over all nodes.  Avoid all the I/O processes
          occupying the same node.

          In the inter-communications (asynchronous) mode, the I/O tasks
          are a disjointed set of dedicated I/O processes and do not
          perform computations. It is possible to have several groups of
          computational units running separate models (coupling) where
          all the I/O data are sent to dedicated processes. Asynchronous
          I/O is still under development and not recommended for use at
          this time.
</code></pre>
<ul>
<li>
<p>PIO rearranger methods for moving data between computational and I/O<br>
processes:</p>
<p>[1] Box rearrangement<br>
[2] Subset rearrangement</p>
</li>
</ul>
<p>PIO_REARR    Rearrangement method between computational and I/O processes. It<br>
provides the ability to rearrange data between computational<br>
and parallel I/O decompositions.</p>
<pre><code>          In the box method, data is rearranged from computational to I/O
          processes in a continuous manner to the data ordering in the
          file. Since the ordering of data between computational and I/O
          partitions may be different, the rearrangement will require
          all-to-all MPI communications. Also, notice that each computing
          tile may transfer data to one or more I/O processes.

          In the subset method, each I/O process is associated with a
          subset of computing processes. The computing tile sends its data
          to a unique I/O process. The data on I/O processes may be more
          fragmented to the ordering on disk, which may increase the
          communications to the storage medium. However, the rearrangement
          scales better since all-to-all MPI communications are not
          required.
</code></pre>
<ul>
<li>
<p>PIO rearranger MPI communication flag:</p>
<p>[0] Point-to-Point (basic send/receive individual operations)<br>
[1] Collective (high-level gather/scatter grouped operations)</p>
</li>
</ul>
<p>PIO_REARRCOM  Type of communications between computational to I/O processes.<br>
In some systems with a generic MPI library implementation, the<br>
Point-to-Point communications are more efficient.</p>
<ul>
<li>
<p>PIO rearranger MPI communications direction control flag:</p>
<p>[0] Enable computational to I/O processes, and vice versa<br>
[1] Enable computational to I/O processes only<br>
[2] Enable I/O to computational processes only<br>
[3] Disable flow control</p>
</li>
</ul>
<p>PIO_REARRDIR Flow control algorithm between computational and I/O processes:</p>
<pre><code>          Optimally, MPI communications should be designed to send a modest
          number messages evenly distributed across a number of processes.
          An excessive number of messages to a single MPI-process can
          exhaust the buffer space which can affect efficiency or failure
          due to the slowdown in the retransmitting of dropped messages.
          PIO only send messages (Isend) when the receiver is ready and
          has sufficient resources.
</code></pre>
<ul>
<li>PIO rearranger options for communications from computational to I/O<br>
processes (C2I):</li>
</ul>
<p>PIO_C2I_HS   Logical switch (T/F) to enable C2I exchange handshake<br>
PIO_C2I_Send Logical switch (T/F) to enable C2I MPI-Isends<br>
PIO_C2I_Preq Maximum pending C2I requests</p>
<ul>
<li>PIO rearranger options for communications from I/O to computational<br>
processes (I2C):</li>
</ul>
<p>PIO_I2C_HS   Logical switch (T/F) to enable I2C exchange handshake<br>
PIO_I2C_Send Logical switch (T/F) to enable I2C MPI-Isends<br>
PIO_I2C_Preq Maximum pending I2C requests</p>
<ul>
<li>
<p>NetCDF-4/HDF5 compression parameters for output files:</p>
<p>This capability is used when both HDF5 and DEFLATE C-preprocessing<br>
options are  activated. The user needs to compile with the NetCDF-4<br>
(HDF5) and MPI libraries. File deflation cannot be used in parallel<br>
I/O for writing because the compression makes it impossible for the<br>
HDF5 library to exactly map the data to the disk location.  For more<br>
information, check NetCDF official website:</p>
<p>www.unidata.ucar.edu/software/netcdf</p>
</li>
</ul>
<p>NC_SHUFFLE   Shuffle filter integer flag. If non-zero, turn on shuffle<br>
filter.</p>
<p>NC_DEFLATE   Deflate filter integer flag, If non-zero, turn on deflate<br>
filter at the level specified by the NC_DLEVEL parameter.</p>
<p>NC_DLEVEL    Deflate filter level parameter (integer). If NC_DEFLATE is<br>
non-zero, set the deflate level to this value. Must be<br>
between 0 and 9.</p>
<hr>
<h2 id="inputoutput-netcdf-filenames-string-with-a-maximum-of-256-characters">Input/output NetCDF filenames (string with a maximum of 256 characters).</h2>
<p>Input filenames:</p>
<p>GRDNAME     Input grid filename.</p>
<p>ININAME     Input nonlinear initial conditions filename. It can be a<br>
re-start file.</p>
<p>ITLNAME     Input tangent linear model initial conditions filename.</p>
<p>IRPNAME     Input representer model initial conditions filename.</p>
<p>IADNAME     Input adjoint model initial conditions filename.</p>
<p>FWDNAME     Input forward solution fields filename.</p>
<p>ADSNAME     Input adjoint sensitivity functional filename.</p>
<p>Input adjoint forcing filenames for computing observations impacts<br>
during the analysis-forecast cycle when RBL4DVAR_FCT_SENSITIVITY is<br>
activated.  The files FOInameA and FOInameB are used when the forecast<br>
metric is defined in state-space (CPP option OBS_SPACE is off). Both<br>
are regular adjoint forcing files just like ADSname.</p>
<p>(See www.myroms.org/wiki/Analysis-Forecast_Cycle_Observation_Impacts)</p>
<p>FOInameA    Forecast initialized with 4D-Var analysis (red curve)</p>
<p>FOInameB    Forecast initialized with 4D_Var background (blue curve)</p>
<p>Input NetCDF filenames for the forecasts initialized from the 4D-Var<br>
analysis files:</p>
<p>FCTnameA    Current  4D-Var analysis cycle (red curve)</p>
<p>FCTnameB    Previous 4D-Var analysis cycle (blue curve)</p>
<p>Nesting grids connectivity data:</p>
<p>NGCNAME     Input nested grids contact points information filename. This<br>
NetCDF file is currently generated using script:</p>
<pre><code>            matlab/grid/contact.m

            from the ROMS Matlab repository.  The nesting information
            is not trivial and this Matlab scripts is quite complex. See

            https://www.myroms.org/wiki/index.php/Nested_Grids
            https://www.myroms.org/wiki/index.php/Grid_Processing_Scripts

            for more information.
</code></pre>
<p>Input lateral boundary conditions file(s) name:</p>
<p>NBCFILES    Number of unique boundary files per nested grid.</p>
<p>BRYNAME     Input open boundary data filename(s) per nested grid.</p>
<p>The USER has the option to enter several filenames for the lateral<br>
boundary conditions variables and or split input data time records for<br>
each nested grid. For example, the USER may have different files for<br>
physical, biology, and sediment state variables. The model will scan<br>
the file list and will read the needed data from the first file in the<br>
list containing the lateral boundary variable. Therefore, the order of<br>
the filenames is critical. It is also possible to split input data<br>
time records into several NetCDF files.</p>
<pre><code>NBCFILES == 2                             number of boundary files

 BRYNAME == my_physics_bry_year1.nc |     physical kernel variables
            my_physics_bry_year2.nc \
            my_biology_bry_year1.nc |     biological tracers
            my_biology_bry_year2.nc
</code></pre>
<p>Input climatology file(s) name:</p>
<p>NCLMFILES   Number of unique climatology files per nested grid.</p>
<p>CLMNAME     Input climatology data filename(s) per nested grid.</p>
<p>The USER has the option to enter several filenames for the climatology<br>
variables and or split input data time records for each nested grid.<br>
For example, the USER may have different files for physical, biology,<br>
and sediment state variables. The model will scan the file list and<br>
will read the needed data from the first file in the list containing<br>
the lateral climatology variable. Therefore, the order of the filenames<br>
is critical. It is also possible to split input data time records into<br>
several NetCDF files.</p>
<pre><code>NCLMFILES == 2                            number of climatology files

  CLMNAME == my_physics_clm_year1.nc |    physical kernel variables
             my_physics_bry_year2.nc \
             my_biology_bry_year1.nc |    biological tracers
             my_biology_bry_year2.nc
</code></pre>
<p>Input nudging coefficients filename:</p>
<p>NUDNAME      Input nudging coefficients filename.</p>
<p>Input Sources/Sinks forcing filename:</p>
<p>SSFNAME      River runoff data. This file is now separated from the<br>
regular forcing files to allow manipulations over nested<br>
grids.  A particular nesting grid may or may not have<br>
Sources/Sinks forcing.</p>
<pre><code>            For example, in an application with 3 nested grids but
            with river forcing in grids 1 and 3 we would have:

                LuvSrc == T F T
            LtracerSrc == 2*T 2*F 2*T

               SSFNAME == my_rivers_grid1.nc \
                          my_rivers_grid2.nc \
                          my_rivers_grid3.nc

            Here, &quot;my_rivers_grid2.nc&quot; is a dummy name that will never
            be processed in ROMS because of the logical switches are
            FALSE the second grid.
</code></pre>
<p>Input/output tidal forcing filename:</p>
<p>TIDENAME     Tidal constituents period, phase, elevation, and current data.<br>
This data is needed when SSH_TIDES, UV_TIDES, or both are<br>
activated to force tides at the open boundaries. Currently,<br>
in nested applications, the tidal forcing is used in the<br>
coarser/larger grid (ng=1). If AVERAGES_DETIDE is activated,<br>
several least-squares time-accumulated harmonic variables<br>
are written into this NetCDF file to facilitate restart for<br>
during long fitting simulations.</p>
<p>Input forcing file(s) name:</p>
<p>NFFILES      Number of unique forcing files per nested grid.</p>
<p>FRCNAME      Input forcing fields filename per nested grid.</p>
<p>The USER has the option to enter several filenames for forcing fields<br>
and or split input data time records for each nested grid. For example,<br>
the USER may have different files for wind products, heat fluxes, etc.<br>
The model will scan the file list and will read the needed data from<br>
the first file in the list containing the forcing field. Therefore,<br>
the order of the filenames is essential. It is also possible to split<br>
input data time records into several NetCDF files.</p>
<p>Use a single line per entry with a continuation () or vertical bar (|)<br>
symbol after each entry, except the last one:</p>
<pre><code>NFFILES == 6                           number of unique forcing files

FRCNAME == my_lwrad_year1.nc |         net longwave radiation flux
           my_lwrad_year2.nc \
           my_swrad_year1.nc |         solar shortwave radiation flux
           my_swrad_year2.nc \
           my_winds_year1.nc |         surface winds
           my_winds_year2.nc \
           my_Pair_year1.nc  |         surface air pressure
           my_Pair_year2.nc  \
           my_Qair_year1.nc  |         surface air relative humidity
           my_Qair_year2.nc  \
           my_Tair_year1.nc  |         surface air temperature
           my_Tair_year2.nc
</code></pre>
<p>Output filenames:</p>
<p>DAINAME      Output data assimilation next cycle initial conditions (4D-Var<br>
analysis) or restart (Ensemble Kalman Filter, EnKF) filename.<br>
GSTNAME      Output GST analysis re-start filename.<br>
RSTNAME      Output re-start filename.<br>
HISNAME      Output history filename.<br>
QCKNAME      Output quicksave filename.<br>
TLFNAME      Output impulse forcing for tangent linear (TLM and RPM) models.<br>
TLMNAME      Output tangent linear filename.<br>
ADJNAME      Output adjoint filename.<br>
AVGNAME      Output averages filename.<br>
HARNAME      Output least-squares detiding harmonics filename.<br>
DIANAME      Output diagnostics filename.<br>
STANAME      Output stations filename.<br>
FLTNAME      Output floats filename.</p>
<hr>
<h2 id="input-ascii-parameters-filenames">Input ASCII parameters filenames.</h2>
<p>APARNAM      Input assimilation parameters filename.<br>
SPOSNAM      Input stations positions filename.<br>
FPOSNAM      Input initial drifters positions filename.<br>
BPARNAM      Input biological parameters filename.<br>
SPARNAM      Input sediment transport parameters filename.<br>
USRNAME      USER's input generic filename.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我又回来了]]></title>
        <id>https://Yvqean.github.io/post/wo-you-hui-lai-liao/</id>
        <link href="https://Yvqean.github.io/post/wo-you-hui-lai-liao/">
        </link>
        <updated>2021-09-22T07:54:10.000Z</updated>
        <content type="html"><![CDATA[<p>上一个阿里云的服务器没钱续费了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://Yvqean.github.io/post/hello-gridea/</id>
        <link href="https://Yvqean.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>